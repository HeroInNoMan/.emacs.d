#+TITLE: Emacs configuration file
#+AUTHOR: Arthur Léothaud
#+EMAIL: arthur@leothaud.eu
#+PROPERTY: header-args :tangle yes
#+auto_tangle: t

#+STARTUP: showall

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+LANGUAGE: en

#+LINK_HOME: http://leothaud.eu
#+HTML_HEAD: <link rel=stylesheet type=text/css href=org.css />

* Startup
  Display emacs startup time, with the number of garbage collections during the process.
  #+BEGIN_SRC emacs-lisp
    ;; Use a hook so the message doesn't get clobbered by other messages.
    (add-hook 'emacs-startup-hook
              (lambda ()
                (message "Emacs ready in %s with %d garbage collections."
                         (format "%.2f seconds"
                                 (float-time
                                  (time-subtract after-init-time before-init-time)))
                         gcs-done)))
  #+END_SRC

  Start by “disabling” garbage collection while starting up:
  #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold most-positive-fixnum)
    ;; restore after startup
    (add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 20000000)))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (setq comp-deferred-compilation t)
    (setq warning-suppress-types '((comp)))
  #+END_SRC

* Package Management

  I decided to move to [[https://github.com/raxod502/straight.el][straight.el]] to manage my config, as it seems more solid and predictable.

  This is how straight is being bootstrapped itself:
  #+BEGIN_SRC emacs-lisp
    (defvar bootstrap-version)
    (let ((bootstrap-file
           (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
          (bootstrap-version 5))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))
  #+END_SRC

  and then configured so I can still use [[https://github.com/jwiegley/use-package][use-package]] to manage my packages and modules.
  #+BEGIN_SRC emacs-lisp
    (straight-use-package 'use-package)
    (setq straight-use-package-by-default t
          use-package-always-defer nil
          use-package-verbose t)
  #+END_SRC

  [[https://elpa.gnu.org/packages/delight.html][delight]] helps unclutter the mode-line with useless minor mode indications.
  #+BEGIN_SRC emacs-lisp
    (use-package delight :defer t)
  #+END_SRC

  [[https://www.emacswiki.org/emacs/key-chord.el][key-chords.el]] is now part of use-package. Check out this [[https://www.youtube.com/watch?v=NXTf8_Arl1w][90 seconds video]] if you don’t know what key-chords is!
  #+BEGIN_SRC emacs-lisp
    (use-package use-package-chords
      :config
      (key-chord-mode 1)
      (setq key-chord-one-key-delay 0.25)
      (setq key-chord-two-keys-delay 0.05))
  #+END_SRC

  I tried to use [[https://github.com/lastquestion/explain-pause-mode/][explain-pause-mode]] to monitor why emacs sometimes slows down, but it seems to mess with key-chords.
  #+BEGIN_SRC emacs-lisp
    (use-package explain-pause-mode
      :disabled
      :config (explain-pause-mode t))
  #+END_SRC

  To allow startup time analysis, I use [[https://github.com/jschaf/esup][esup]]:
  #+BEGIN_SRC emacs-lisp
    (use-package esup :defer t)
  #+END_SRC

* Emacs directory
  Let’s keep ~~/.emacs.d~ tidy:
  #+BEGIN_SRC emacs-lisp
    (use-package no-littering
      :config
      (require 'recentf)
      (setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
      (add-to-list 'recentf-exclude no-littering-var-directory)
      (add-to-list 'recentf-exclude no-littering-etc-directory))
  #+END_SRC

  Private information is stored in variables in ~~/.emacs.d/private.el~.
  #+BEGIN_SRC emacs-lisp
    (let ((private-file (expand-file-name "private.el" base-emacs-directory)))
      (when (file-exists-p private-file)
        (load-file private-file)))
  #+END_SRC

  Let’s load all files from the “extra” directory (will happen after init is finished).
  #+BEGIN_SRC emacs-lisp
    (use-package load-dir
      :defer t
      :config (setq load-dirs (expand-file-name "extra/" base-emacs-directory)))
  #+END_SRC

  Custom file should be loaded early. Edit: let’s try not to use a custom file at all and do everything in ~emacs.org~.
  #+BEGIN_SRC emacs-lisp
    (setq-local custom-file-enabled nil) ;; enable / disable custom-file loading
    (setq-default custom-file (expand-file-name "custom.el" base-emacs-directory))
    (when (and custom-file-enabled
               (file-exists-p custom-file))
      (load custom-file))
  #+END_SRC

  Let’s allow tangling files without confirmation
  #+BEGIN_SRC emacs-lisp
    (setq-default safe-local-variable-values
                  '((eval add-hook 'after-save-hook
                          (lambda nil
                            (org-babel-tangle))
                          nil t)))
  #+END_SRC

* Custom functions
  My custom (often stolen) lisp code is stored in ~elisp/my-functions.el~.
  #+BEGIN_SRC emacs-lisp
    (use-package my-functions ;; custom functions
      :straight nil
      :demand
      :load-path "elisp/"
      :bind
      ("C-S-p" . up-arrow)
      ("C-S-n" . down-arrow)
      ("C-M-S-p" . scroll-down-line)
      ("C-M-S-n" . scroll-up-line)
      ("M-é" . previous-user-buffer)                   ;; call previous user buffer
      ("M-è" . next-user-buffer)                       ;; call next user buffer
      ("C-M-é" . previous-buffer)                      ;; call previous buffer
      ("C-M-è" . next-buffer)                          ;; call next buffer
      ([remap goto-line] . 'goto-line-with-feedback)   ;; display linum while goto-line
      ("C-x |" . ale/toggle-window-split)
      ("C-|" . ale/toggle-window-split)
      ("C-%" . ale/toggle-selective-display)
      ("C-x _" . ale/toggle-camel-snake-kebab-case)
      ("C-c +" . increment-number-decimal)
      ("C-c -" . decrement-number-decimal))
  #+END_SRC

* Help
  [[https://github.com/justbur/emacs-which-key][which-key]] displays all available bindings for the prefix that has just been typed (replaces [[https://github.com/kai2nenobu/guide-key][guide-key]]).
  #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :hook ((prog-mode text-mode) . which-key-mode)
      :config
      (which-key-mode)
      (setq which-key-idle-delay 0.3))
  #+END_SRC

  [[https://github.com/Wilfred/helpful][Helpful]] adds more contextual information to the built-in help.
  #+BEGIN_SRC emacs-lisp
    (use-package helpful
      :bind
      ;; Note that the built-in `describe-function' includes both functions
      ;; and macros. `helpful-function' is functions only, so we provide
      ;; `helpful-callable' as a drop-in replacement.
      ("C-h f" . helpful-callable)
      ("C-h v" . helpful-variable)
      ("C-h k" . helpful-key)
      ;; Lookup the current symbol at point. C-c C-d is a common keybinding
      ;; for this in lisp modes.
      ("C-c C-d" . helpful-at-point)

      ;; Look up *F*unctions (excludes macros).
      ;;
      ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
      ;; already links to the manual, if a function is referenced there.
      ("C-h F" . helpful-function)

      ;; Look up *C*ommands.
      ;;
      ;; By default, C-h C is bound to describe `describe-coding-system'. I
      ;; don't find this very useful, but it's frequently useful to only
      ;; look at interactive functions.
      ("C-h C" . helpful-command))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package describe-number :defer t)
  #+END_SRC

* Defaults
  Let’s redefine some basic behaviour:

  First, let’s remove menus, toolbar, scrollbar, fringes.
  #+BEGIN_SRC emacs-lisp
    (menu-bar-mode -1)
    (when (fboundp 'tool-bar-mode)
      (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
    (when (fboundp 'horizontal-scroll-bar-mode)
      (horizontal-scroll-bar-mode -1))
    (when (display-graphic-p)
      (fringe-mode 0))
  #+END_SRC

  Although I mainly use helm, ido is nice in some cases.
  #+BEGIN_SRC emacs-lisp
    (use-package ido
      :straight nil
      :config
      (setq ido-max-prospects 25)
      (ido-mode t)
      (setq ido-case-fold t
            ido-enable-flex-matching t))
  #+END_SRC

  Let’s use UTF-8 everywhere:
  #+BEGIN_SRC emacs-lisp
    (use-package mule
      :straight nil
      :config
      (prefer-coding-system       'utf-8)
      (set-default-coding-systems 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (setq default-buffer-file-coding-system 'utf-8))
  #+END_SRC

  Some environments don’t handle dead keys.
  #+BEGIN_SRC emacs-lisp
    (use-package iso-transl :straight nil :defer t)
  #+END_SRC

  Let’s [[https://github.com/iqbalansari/emacs-emojify][emojify]] things :
  #+BEGIN_SRC emacs-lisp
    (use-package emojify
      :hook ((text-mode erc-mode) . (lambda () (emojify-mode t))))
  #+END_SRC

  Some commands are disabled by default, let’s enable them:
  #+BEGIN_SRC emacs-lisp
    (put 'downcase-region 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'narrow-to-region 'disabled nil)
    (put 'narrow-to-page 'disabled nil)
    (put 'scroll-left 'disabled nil)
  #+END_SRC

  This is supposed to improve performances when dealing with very long lines:
  #+BEGIN_SRC emacs-lisp
    (setq bidi-paragraph-direction 'left-to-right)

    (when (version<= "27.1" emacs-version)
      (progn
        (setq bidi-inhibit-bpa t)
        (global-so-long-mode 1)))
  #+END_SRC

  Let’s add some auto-backup configuration:
  #+BEGIN_SRC emacs-lisp
    (use-package saveplace
      :straight nil
      :config
      (setq-default save-place t)
      (setq save-place-file (expand-file-name "places" base-emacs-directory)
            vc-make-backup-files t ;; make backups of files, even when they're in version control
            backup-directory-alist `(("." . ,(expand-file-name "backups"
                                                               base-emacs-directory)))))
  #+END_SRC

  More miscellaneous configuration and bindings, grouped by built-in packages:
  #+BEGIN_SRC emacs-lisp
    (use-package simple
      :straight nil
      :bind
      ("C-x C-u" . upcase-dwim)
      ("C-x C-l" . downcase-dwim)
      ("C-x C-c" . capitalize-dwim)
      ("M-%" . count-words)
      ("C-x C-z" . repeat-complex-command)
      ("C-c w" . delete-trailing-whitespace)
      ("M-«" . beginning-of-buffer)
      ("M-»" . end-of-buffer)
      :config
      (setq global-mark-ring-max 256
            set-mark-command-repeat-pop t
            mark-ring-max 256
            kill-ring-max 256
            line-number-mode t    ;; Always display line number
            column-number-mode t  ;; and column number
            shift-select-mode nil ;; don't use shift to mark things
            save-interprogram-paste-before-kill t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (autoload 'zap-up-to-char "misc"
      "Kill up to, but not including ARGth occurrence of CHAR." t)
    (global-set-key (kbd "M-z") 'zap-up-to-char)

    (setq apropos-do-all t
          mouse-yank-at-point t
          require-final-newline t
          load-prefer-newer t)
    ;; Answer questions with y/n
    (defalias 'yes-or-no-p 'y-or-n-p)

    ;; Transparently open compressed files
    (auto-compression-mode t)

    ;; some more config
    (setq recentf-max-saved-items 100  ;; just 20 is too recent
          delete-by-moving-to-trash t ;; move files to trash when deleting
          savehist-additional-variables '(register-alist))
    (recentf-mode 1)
    (savehist-mode 1)

    ;; Lines should be 80 characters wide, not 70
    (setq-default fill-column 80)

    ;; fill or unfill paragraph (M-q as a toggle)
    (defun endless/fill-or-unfill ()
      "Like `fill-paragraph', but unfill if used twice."
      (interactive)
      (let ((fill-column
             (if (eq last-command 'endless/fill-or-unfill)
                 (progn (setq this-command nil)
                        (point-max))
               fill-column)))
        (call-interactively #'fill-paragraph)))
    (global-set-key [remap fill-paragraph]
                    #'endless/fill-or-unfill)

    (global-font-lock-mode t) ;; enable syntax highlighting
    (blink-cursor-mode -1) ;; no blinking cursor

    (setq-default transient-mark-mode t ;; Show active region
                  truncate-lines t ;; Don't soft-break lines for me, please
                  truncate-string-ellipsis "…")

    (setq font-lock-maximum-decoration t ;; all possible colours
          inhibit-startup-screen t ;; No splash screen
          echo-keystrokes 0.1 ;; Show keystrokes in progress
          initial-scratch-message nil ;; No *scratch* message
          initial-major-mode 'text-mode
          visible-bell nil) ;; No flashing!
  #+END_SRC

  I don’t usually display line numbers, but I want the abilitity to do so, and also to display relative line numbering, which is handy to navigate using numeric arguments.
  #+BEGIN_SRC emacs-lisp
    (use-package linum-relative
      :defer t
      :config (setq linum-relative-current-symbol ""))
  #+END_SRC

  [[https://github.com/bbatsov/crux][Crux]] brings a lot of better default behaviour and functions.
  #+BEGIN_SRC emacs-lisp
    (use-package crux
      ;; replace some commands
      :bind
      ("C-M-<down>" . crux-duplicate-current-line-or-region)
      ("C-M-<up>" . crux-duplicate-and-comment-current-line-or-region)
      ("M-j" . crux-top-join-line)
      ("M-o" . crux-other-window-or-switch-buffer)
      ("C-x C-r" . crux-sudo-edit)
      ("C-S-d" . kill-whole-line)
      ("C-c i" . crux-cleanup-buffer-or-region)
      ("M-\"" . ale/new-scratch-or-reuse)
      ("C-S-o" . crux-smart-open-line-above)
      ("C-S-j" . crux-smart-open-line)
      ("C-S-k" . crux-smart-kill-line)
      ([remap move-beginning-of-line] . crux-move-beginning-of-line)
      ([remap kill-whole-line] . crux-kill-whole-line)
      :config
      (crux-reopen-as-root-mode)
      ;; advices to make region-aware commands act on whole line if no region
      (crux-with-region-or-line comment-or-uncomment-region)
      ;; advices to make region-aware commands act on whole buffer if no region
      (crux-with-region-or-buffer indent-region)
      (crux-with-region-or-buffer untabify)
      (crux-with-region-or-buffer tabify))
  #+END_SRC

* Keybindings

  [[https://github.com/alphapapa/defrepeater.el][defrepeater]] is useful to define repeatable key bindings:

  #+BEGIN_SRC emacs-lisp
    (use-package defrepeater
      :config
      (global-set-key [remap increment-number-decimal] (defrepeater 'increment-number-decimal))
      (global-set-key [remap decrement-number-decimal] (defrepeater 'decrement-number-decimal))
      (global-set-key [remap goto-last-change]         (defrepeater 'goto-last-change))
      (global-set-key [remap previous-error]           (defrepeater 'previous-error))
      (global-set-key [remap next-error]               (defrepeater 'next-error))
      (global-set-key [remap flycheck-previous-error]  (defrepeater 'flycheck-previous-error))
      (global-set-key [remap flycheck-next-error]      (defrepeater 'flycheck-next-error))
      (global-set-key [remap bury-buffer]              (defrepeater 'bury-buffer))
      (global-set-key [remap shrink-whitespace]        (defrepeater 'shrink-whitespace)))
  #+END_SRC

  I use [[https://github.com/abo-abo/hydra][hydra]] in order to map ranges of key bindings:
  #+BEGIN_SRC emacs-lisp
    (use-package hydra :defer t)
    (use-package pretty-hydra :defer t)
  #+END_SRC

  Killing emacs; default binding is too easy to hit by accident.
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-x C-c")
                    #'(lambda () (interactive)
                        (message "Use C-x r q (r·eally q·uit) to kill emacs.")))
    (global-set-key (kbd "C-x r q") 'kill-emacs) ;; r·eally q·uit
  #+END_SRC

  I never use the minimise command, use the binding for =repeat= instead.
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-z") 'repeat)
  #+END_SRC

  Vim’s “dot” is a cool macro-like feature. I want that.
  #+BEGIN_SRC emacs-lisp
    (use-package dot-mode
      :chords ("pz" . dot-mode-execute)
      :config
      ;; default bindings I already use
      (unbind-key "C-." dot-mode-map)
      (unbind-key "C-c ." dot-mode-map)
      (global-dot-mode))
  #+END_SRC

  Text completion is everything. The order in which the completion functions are called makes quite a difference.
  #+BEGIN_SRC emacs-lisp
    (use-package hippie-exp
      :straight nil
      :bind ("M-/" . hippie-expand)
      :config
      (setq hippie-expand-try-functions-list
            '(try-complete-file-name-partially
              try-complete-file-name
              try-expand-list
              try-expand-all-abbrevs
              try-expand-dabbrev
              try-expand-dabbrev-all-buffers
              try-expand-dabbrev-from-kill
              try-complete-lisp-symbol-partially
              try-complete-lisp-symbol
              try-expand-line)))
  #+END_SRC

* Modal editing
  I use [[https://github.com/chrisdone/god-mode][god-mode]] to implement a pseudo-modal behaviour. The cursor becomes red when in god-mode to make it more visible.
  #+BEGIN_SRC emacs-lisp
    (use-package god-mode
      :init (setq god-local-mode nil)
      :bind
      (("C-c g" . toggle-god-mode)
       :map god-local-mode-map
       ("i" . toggle-god-mode)
       ("." . repeat))
      :config
      (defun toggle-god-mode ()
        (interactive)
        (progn
          (god-mode-all)
          (my-update-cursor)))
      (setq god-mode-colors nil)
      (defun my-update-cursor ()
        "change cursor colour if god-mode is activated/deactivated effectively."
        (cond
         (god-local-mode
          (progn
            (set-cursor-color "red")
            (setq god-mode-colors t)
            (setq cursor-type 'box)))
         (t
          (progn
            ;; TODO aller choper dynamiquement la couleur de base du curseur (ou mieux
            ;; définir une face cursor-color-god ou un truc comme ça)
            (set-cursor-color original-cursor-color)
            (setq god-mode-colors nil)
            (if buffer-read-only
                (setq cursor-type 'box)
              (setq cursor-type 'box))))))

      (defadvice select-window (after update-cursor-color activate)
        (my-update-cursor))
      (add-to-list 'god-exempt-major-modes 'helm-major-mode)
      (add-to-list 'god-exempt-major-modes 'browse-kill-ring-mode)
      (add-to-list 'god-exempt-major-modes 'ibuffer-mode))
  #+END_SRC

* Appearance

  Always start in full screen.
  #+BEGIN_SRC emacs-lisp
    (use-package frame
      :straight nil
      :config
      (if (eq window-system 'ns)
          (toggle-frame-maximized)
        (toggle-frame-fullscreen)))
  #+END_SRC

  Set frame title to buffer name and mode:
  #+BEGIN_SRC emacs-lisp
    (setq-default frame-title-format '("%b [%m]"))
  #+END_SRC

  Set default window size to standard 80 × 24:
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'default-frame-alist '(height . 24))
    (add-to-list 'default-frame-alist '(width . 80))
  #+END_SRC

** Theme

*** Doom themes
    #+BEGIN_SRC emacs-lisp
      (use-package doom-themes
        :config
        (setq custom-safe-themes
              '("0d01e1e300fcafa34ba35d5cf0a21b3b23bc4053d388e352ae6a901994597ab1"
                "1526aeed166165811eefd9a6f9176061ec3d121ba39500af2048073bea80911e"
                "1a52e224f2e09af1084db19333eb817c23bceab5e742bf93caacbfea5de6b4f6"
                "3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa"
                "79278310dd6cacf2d2f491063c4ab8b129fee2a498e4c25912ddaa6c3c5b621e"
                "7f791f743870983b9bb90c8285e1e0ba1bf1ea6e9c9a02c60335899ba20f3c94"
                "80147cd7121944101fb451c69800c8565db80b5b819754118d96a28be6ea1054"
                "a27c00821ccfd5a78b01e4f35dc056706dd9ede09a8b90c6955ae6a390eb1c1e"
                "c74e83f8aa4c78a121b52146eadb792c9facc5b1f02c917e3dbb454fca931223"
                "dde8c620311ea241c0b490af8e6f570fdd3b941d7bc209e55cd87884eb733b0e"
                "e1ecb0536abec692b5a5e845067d75273fe36f24d01210bf0aa5842f2a7e029f"
                "f4fefd141d606f337880a642f20cfd0472ebe2d8a339741faa4ae222ec250bfb"
                "fa3bdd59ea708164e7821574822ab82a3c51e262d419df941f26d64d015c90ee"
                default))
        ;; Global settings (defaults)
        (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
              doom-themes-enable-italic t) ; if nil, italics is universally disabled
        (load-theme (if (boundp 'my-private-theme) my-private-theme 'doom-vibrant))

        (setq original-cursor-color (face-attribute 'cursor :background))
        (setq original-cursor-color "#51afef")

        ;; Enable flashing mode-line on errors
        ;; (doom-themes-visual-bell-config)

        ;; Enable custom neotree theme (all-the-icons must be installed!)
        ;; (doom-themes-neotree-config)
        ;; or for treemacs users
        (setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
        (doom-themes-treemacs-config)

        ;; Corrects (and improves) org-mode's native fontification.
        (doom-themes-org-config))
    #+END_SRC

*** Alternative themes
    #+BEGIN_SRC emacs-lisp
      (use-package amethyst
        :defer t
        :straight '(amethyst :host github :repo "ashton314/amethyst"))
    #+END_SRC

** Zoom
   I use [[https://github.com/purcell/default-text-scale][default-text-scale]] to zoom in and out the frames of the current instance of emacs.
   #+BEGIN_SRC emacs-lisp
     (use-package default-text-scale
       :bind
       ("C-+" . default-text-scale-increase)
       ("C-=" . default-text-scale-decrease)
       :config
       (setq default-text-scale-amount 5)
       (defadvice default-text-scale-increase (after fix-font activate) (set-fira-font-if-possible))
       (defadvice default-text-scale-decrease (after fix-font activate) (set-fira-font-if-possible))
       (defadvice default-text-scale-reset (after fix-font activate) (set-fira-font-if-possible)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package font-size
       :straight '(font-size :host github :repo "nabeix/emacs-font-size")
       :bind
       ("M-+" . font-size-increase)
       ("M-=" . font-size-decrease)
       ;; ("M-0" . font-size-default)
       :config (font-size-init 10)
       (defadvice font-size-increase (after fix-font activate) (set-fira-font-if-possible))
       (defadvice font-size-decrease (after fix-font activate) (set-fira-font-if-possible))
       (defadvice font-size-default (after fix-font activate) (set-fira-font-if-possible)))
   #+END_SRC

** Highlight feedback
   Let’s have a visual feedback when performing cut/copy/paste operations.
   #+BEGIN_SRC emacs-lisp
     (use-package goggles
       :hook (prog-mode . goggles-mode)
       :config
       (setq-default goggles-pulse t) ;; set to nil to disable pulsing
       (setq goggles-pulse-delay 0.05))

     (use-package idle-highlight-mode
       :hook prog-mode
       :custom-face (idle-highlight ((t (:background "gray10"))))
       :config (setq idle-highlight-idle-time 0.3)) ;; default 0.5
   #+END_SRC

   Highlight current line in list buffers:
   #+BEGIN_SRC emacs-lisp
     (use-package hl-line
       :straight nil
       :custom-face (hl-line ((t (:background "grey7"))))
       :hook (dired-mode . hl-line-mode)
       :config (global-hl-line-mode -1))

     (use-package highlight-indent-guides
       :hook (prog-mode . highlight-indent-guides-mode)
       :custom-face (highlight-indent-guides-character-face ((t (:foreground "gray15"))))
       :config (setq highlight-indent-guides-method 'character))
   #+END_SRC

   Prettify those ugly ==
   #+BEGIN_SRC emacs-lisp
     (use-package page-break-lines
       :hook (help-mode . global-page-break-lines-mode))
   #+END_SRC

   Beacon gives a nice visual feedback when the cursor moves around.
   #+BEGIN_SRC emacs-lisp
     (use-package beacon :defer t)
   #+END_SRC

** Icons in terminal
   #+BEGIN_SRC emacs-lisp
     (use-package font-lock+ :defer t)

     (use-package icons-in-terminal
       :disabled
       :straight nil
       :defer t
       :load-path (expand-file-name ".local/share/icons-in-terminal/"
                                    (if (boundp 'my-home-dir) my-home-dir "~")))
     ;; (insert (icons-in-terminal 'oct_flame)) ; C-h f icons-in-terminal[RET] for more info

     (use-package all-the-icons :defer t)
   #+END_SRC

** Colours
   Colour parentheses according to nesting level:
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :hook (prog-mode . rainbow-delimiters-mode)
       :custom-face
       (rainbow-delimiters-depth-1-face
        ((t (:inherit rainbow-delimiters-base-face :foreground "white smoke"))))
       (rainbow-delimiters-depth-2-face
        ((t (:inherit rainbow-delimiters-base-face :foreground "gold"))))
       (rainbow-delimiters-depth-3-face
        ((t (:inherit rainbow-delimiters-base-face :foreground "lawn green"))))
       (rainbow-delimiters-depth-4-face
        ((t (:inherit rainbow-delimiters-base-face :foreground "dark turquoise"))))
       (rainbow-delimiters-depth-5-face
        ((t (:inherit rainbow-delimiters-base-face :foreground "deep pink"))))
       (rainbow-delimiters-depth-6-face
        ((t (:inherit rainbow-delimiters-base-face :foreground "yellow1"))))
       (rainbow-delimiters-depth-7-face
        ((t (:inherit rainbow-delimiters-base-face :foreground "orange"))))
       (rainbow-delimiters-depth-8-face
        ((t (:inherit rainbow-delimiters-base-face :foreground "white"))))
       (rainbow-delimiters-depth-9-face
        ((t (:inherit rainbow-delimiters-base-face :foreground "dark salmon")))))
   #+END_SRC

   In some specific modes, I like to have the syntax highlighting replaced by a colouring according to nesting level.
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-blocks :defer t)

     (use-package prism :defer t)
   #+END_SRC

   Or according to symbol names.
   #+BEGIN_SRC emacs-lisp
     (use-package color-identifiers-mode :defer t)
   #+END_SRC

   When coding, colour codes and names should be displayed in this colour.
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-mode
       :hook (prog-mode . rainbow-mode))
   #+END_SRC
   Note: If I ever need to work seriously with colours: [[https://github.com/emacsfodder/kurecolor][kurecolor]]

   #+BEGIN_SRC emacs-lisp
     (use-package kurecolor :defer t)
   #+END_SRC

* Dired
  #+BEGIN_SRC emacs-lisp
    (use-package dired
      :straight nil
      :bind ("C-x C-j". dired-jump)
      :config
      (unbind-key "M-b" dired-mode-map)
      (put 'dired-find-alternate-file 'disabled nil)
      (setq dired-dwim-target t
            ;; dired human readable size format
            dired-listing-switches "-AlhF"
            auto-revert-verbose nil
            ;; always delete and copy recursively
            dired-recursive-deletes 'always
            dired-recursive-copies 'always))

    (use-package all-the-icons-dired
      :after dired
      :hook (dired-mode . all-the-icons-dired-mode))

    (use-package diredfl
      :after dired
      :hook (dired-mode . diredfl-mode))

    (use-package dired-narrow
      :after dired
      :bind (:map dired-mode-map ("/" . dired-narrow)))

    (use-package find-dired
      :after dired
      :config (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld")))

    (use-package dired-collapse
      :after dired
      :hook (dired-mode . dired-collapse-mode))

    (use-package dired-subtree
      :after dired
      :bind (:map dired-mode-map
                  ("U" . dired-subtree-up)
                  ("e" . dired-subtree-narrow)
                  ("i" . dired-subtree-toggle)
                  ("<tab>" . dired-subtree-cycle)
                  ("<backtab>" . dired-subtree-cycle)
                  ("«" . dired-subtree-beginning)
                  ("»" . dired-subtree-end)))

    (use-package dired-quick-sort
      :bind (:map dired-mode-map
                  ("r" . hydra-dired-quick-sort/body)))
  #+END_SRC

* Navigation
  I use [[https://github.com/abo-abo/ace-window][ctrlxo]] to quickly switch windows…
  #+BEGIN_SRC emacs-lisp
    (use-package ctrlxo
      :bind ("C-x o" . ctrlxo))
  #+END_SRC

  … and avy to directly jump to a char.
  #+BEGIN_SRC emacs-lisp
    (use-package avy
      :chords
      ("àà" . avy-goto-line)
      :bind
      ("M-à" . avy-goto-word-1) ;; quickly jump to word by pressing its first letter
      ("M-m" . avy-goto-char) ;; quickly jump to any char in word
      :config
      (setq avy-keys
            '(97 117 105 101 98 233 112 111 116 115 114 110 109 118 100 108 106 99 113 103 104 102)))
  #+END_SRC

  Equivalent of ~f~ key in vim:
  #+BEGIN_SRC emacs-lisp
    (use-package iy-go-to-char
      :chords
      ("««" . iy-go-to-char-backward)
      ("»»" . iy-go-up-to-char))
  #+END_SRC

  I use the nice ~beginend~ package to enhance ~beginning-of-buffer~ and ~end-of-buffer~ commands.
  #+BEGIN_SRC emacs-lisp
    (use-package beginend :defer t)
  #+END_SRC

  Let’s optimise what is displayed in the window:
  #+BEGIN_SRC emacs-lisp
    (use-package fill-page :defer t)
  #+END_SRC

  More navigation commands:
  #+BEGIN_SRC emacs-lisp
    (use-package imenu-anywhere
      :bind ("C-c ." . helm-imenu-anywhere))

    (use-package dumb-jump
      :bind (:map prog-mode-map
                  ("C-." . xref-find-definitions)
                  ("C-," . xref-pop-marker-stack)
                  ("C-;" . dumb-jump-quick-look))
      :config (setq dumb-jump-default-project
                    (if (boundp 'my-default-project-root)
                        my-default-project-root
                      "~")))

    (use-package minimap :defer t
      :config
      (setq minimap-window-location 'right
            minimap-highlight-line nil
            minimap-width-fraction 0.09
            minimap-minimum-width 20
            minimap-hide-cursor t
            minimap-recenter-type 'relative))

    (use-package treemacs :defer t)

    ;; Allow scrolling with mouse wheel
    (when (display-graphic-p) (progn (mouse-wheel-mode t)
                                     (mouse-avoidance-mode 'none)))

    (use-package goto-last-change
      :bind
      ("C-x C-/" . goto-last-change)
      ("C-x /" . goto-last-change))
  #+END_SRC

* Whitespace
  I just heard of [[https://github.com/editorconfig/editorconfig-emacs][editorconfig]], which sounds like a sensible way of dealing with formatting issues accross multiple IDEs/Projects/developers
  #+BEGIN_SRC emacs-lisp
    (use-package editorconfig :defer t)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package aggressive-indent
      :hook (lisp-data-mode . aggressive-indent-mode))

    ;;Indentation
    (setq-default tab-width 2
                  c-auto-newline t
                  c-basic-offset 2
                  c-block-comment-prefix ""
                  c-default-style "k&r"
                  indent-tabs-mode nil ;; <tab> inserts spaces, not tabs and spaces
                  sentence-end-double-space nil) ;; Sentences end with a single space

    ;; use tab to auto-comlete if indentation is right
    (setq tab-always-indent 'complete)

    (use-package shrink-whitespace
      :bind ("C-x C-o" . shrink-whitespace))
  #+END_SRC

* Folding
  I use [[https://github.com/gregsexton/origami.el][origami]]…
  #+BEGIN_SRC emacs-lisp
    (use-package origami
      :hook (prog-mode . origami-mode)
      :config (setq origami-fold-replacement "..."))
  #+END_SRC

  … and [[https://github.com/mrkkrp/vimish-fold][vimish-fold]].
  #+BEGIN_SRC emacs-lisp
    (use-package vimish-fold
      :bind
      (:map vimish-fold-folded-keymap ("<tab>" . vimish-fold-unfold)
            :map vimish-fold-unfolded-keymap ("<tab>" . vimish-fold-refold))
      :config
      (vimish-fold-global-mode 1)
      (setq-default vimish-fold-dir (expand-file-name ".vimish-fold/" base-emacs-directory)
                    vimish-fold-header-width 79))
  #+END_SRC

  I also use =selective-display= as a more simple folding method (cf. package my-functions).

  I use a hydra to have all those commands in one place.
  #+BEGIN_SRC emacs-lisp
    (pretty-hydra-define hydra-fold
      (:color pink :quit-key "q")
      ("built-in"
       (("s" ale/toggle-selective-display "selective display")
        ("n" narrow-to-defun "narrow"))
       "vimish fold"
       (("f" vimish-fold "fold")
        ("k" vimish-fold-delete "kill")
        ("K" vimish-fold-delete-all "kill all")
        ("p" vimish-fold-previous-fold "go previous")
        ("n" vimish-fold-next-fold "go next")
        ("<tab>" vimish-fold-toggle "toggle current")
        ("a" vimish-fold-toggle-all "toggle all"))
       "origami"
       (("x" origami-toggle-all-nodes "toggle all")
        ("y" origami-show-only-node "show only node")
        ("c" origami-recursively-toggle-node "cycle"))
       ))
    (global-set-key (kbd "C-c <tab>") 'hydra-fold/body)
  #+END_SRC
* Search & Navigation
** isearch
   Standard isearch by default:
   #+BEGIN_SRC emacs-lisp
     (use-package isearch-dabbrev
       :bind (:map isearch-mode-map
                   ("<tab>" . isearch-dabbrev-expand)
                   ("M-/" . isearch-dabbrev-expand)))

     (use-package smartscan
       :bind
       ("M-n". smartscan-symbol-go-forward) ;; find next occurence of word at point
       ("M-p". smartscan-symbol-go-backward) ;; find previous occurence of word at point
       ("M-'". smartscan-symbol-replace)) ;; replace all occurences of word at point
   #+END_SRC

** Regular expressions
   #+BEGIN_SRC emacs-lisp
     ;; regexp-builder
     (use-package re-builder
       :defer t
       :config (setq reb-re-syntax 'string)) ;; syntax used in the re-buidler

     (use-package visual-regexp-steroids
       :bind
       (("M-s r" . vr/replace)
        ("M-s q" . vr/query-replace)
        ("C-M-%" . vr/query-replace)
        ("M-s m" . vr/mc-mark) ;; useful with multiple-cursors
        ("M-s C-M-s" . vr/isearch-forward)
        ("M-s C-M-r" . vr/isearch-backward)
        ("M-s S" . isearch-forward)
        ("M-s R" . isearch-backward))
       :config (require 'visual-regexp)) ;; TODO check if really necessary
   #+END_SRC
   Note: there seems to be a [[http://cpansearch.perl.org/src/YEWENBIN/Emacs-PDE-0.2.16/lisp/re-builder-x.el][re-builder supporting perl syntax]].

** CTRLF

   Just found [[https://github.com/raxod502/ctrlf.git][this new attempt]] at improving standard searching:

   #+BEGIN_SRC emacs-lisp
     (use-package ctrlf
       :bind (("C-s" . ctrlf-forward-literal)
              ("C-r" . ctrlf-backward-literal)
              ("C-M-s" . ctrlf-forward-regexp)
              ("C-M-r" . ctrlf-backward-regexp)
              :map minibuffer-local-map
              ("C-s" . ctrlf-forward-literal)
              ("C-r" . ctrlf-backward-literal)
              ("C-w" . ctrlf-forward-symbol-at-point))
       :config (ctrlf-mode)
       :custom-face (ctrlf-highlight-active ((t (:inherit isearch :background "dark orange")))))
   #+END_SRC

** phi-search

   [[https://github.com/zk-phi/phi-search][phi-search]] is nice because it supports [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]].

   #+BEGIN_SRC emacs-lisp
     (use-package phi-search
       :bind
       ("M-s C-s" . phi-search)
       ("M-s C-r" . phi-search-backward)
       :custom-face (phi-search-selection-face ((t (:inherit isearch :background "dark orange")))))
   #+END_SRC

* Completion & help
** Completion
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :hook (prog-mode . global-company-mode)
       :config
       (global-company-mode 1) ;; enable company in all buffers
       (setq company-tooltip-limit 30
             company-idle-delay 0.5 ;; almost no delay before showing candidates
             company-minimum-prefix-length 2 ;; completion rigth away!
             company-show-numbers 'on
             company-dabbrev-downcase nil))

     (use-package company-prescient
       :hook (company-mode . company-prescient-mode)
       :config
       (company-prescient-mode)
       (prescient-persist-mode))

     (use-package company-box
       :hook (company-mode . company-box-mode))

     (use-package browse-kill-ring
       :config
       (browse-kill-ring-default-keybindings)
       (setq browse-kill-ring-quit-action 'save-and-restore))

     ;; case-insensitive policy
     (setq completion-ignore-case t
           pcomplete-ignore-case t
           read-file-name-completion-ignore-case t
           read-buffer-completion-ignore-case t)
   #+END_SRC

** Undo
   [[http://www.dr-qubit.org/undo-tree.html][undo-tree]] is a powerful undo/redo mode that treats undo history as a tree.
   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :demand
       :pretty-hydra
       ((:color teal :quit-key "q")
        ("Navigate"
         (("p" undo-tree-undo "↶ undo" :color red)
          ("n" undo-tree-redo "↷ redo" :color red))
         "Manage"
         (("v" undo-tree-visualize "visualize")
          ("s" undo-tree-save-history "save")
          ("l" undo-tree-load-history "load"))))
       :bind (("C-M-/" . undo-tree-redo)
              ("C-c u" . undo-tree-hydra/body))
       :config
       (setq undo-tree-visualizer-timestamps t
             undo-tree-enable-undo-in-region nil
             undo-tree-visualizer-diff t
             undo-tree-auto-save-history t
             undo-limit 8000000
             undo-outer-limit 3000000)
       (global-undo-tree-mode))
   #+END_SRC

** Helm
   Main =helm= configuration, with a big hydra as an entry point for almost all helm commands I use.
   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :chords
       ("bf" . helm-for-files)                 ;; snappy helm instance
       ("éè" . helm-rg)                        ;; ripgrep. end of story.
       ("«»" . hydra-helm-config/body)         ;; all (useful) helm commands in one hydra
       :bind
       (("M-x" . helm-M-x)                     ;; superior to M-x
        ("C-x M-x" . execute-extended-command) ;; still possible to use standard M-x
        ("C-c h" . hydra-helm-config/body)
        ("C-h a" . helm-apropos)
        :map helm-map
        ("C-S-t"   . helm-toggle-resplit-and-swap-windows) ; remap this one…
        ("C-t"     . transpose-chars) ; so I can still use that one
        ("M-«" . helm-beginning-of-buffer)
        ("M-»" . helm-end-of-buffer)
        ("C-S-t" . helm-toggle-resplit-and-swap-windows)
        ("C-t" . transpose-chars)
        ("C-S-b" . helm-rg--bounce)
        ("C-S-d" . helm-rg--set-dir)
        ("M-d" . kill-word)
        :map minibuffer-local-map
        ("C-c C-l" . helm-minibuffer-history))
       :config
       (require 'helm-config)
       (helm-mode t)                           ;; only on demand
       (helm-autoresize-mode t)
       ;; (semantic-mode 1)                    ;; useful for imenu-like navigation

       (define-key minibuffer-local-map (kbd "C-r") 'ctrlf-backward-literal)

       (defun helm-sql-connect (func)
         "Connect (using input FUNC) to a SQL server."
         (interactive
          (progn (init-server-alist)
                 (helm-comp-read "Select server: " ale-sql-servers-list)))
         (funcall func)
         (when (boundp 'my-private-sql-scratch-buffer)
           (find-file-other-window my-private-sql-scratch-buffer)))

       (setq helm-M-x-fuzzy-match t
             helm-locate-command "locate %s -e -A --regex %s"
             helm-adaptive-mode t
             helm-buffer-max-length nil
             helm-buffers-fuzzy-matching t
             helm-candidate-number-limit 300
             helm-echo-input-in-header-line nil
             helm-external-programs-associations '(("mp3" . "audacious"))
             helm-ff-file-name-history-use-recentf t
             helm-ff-skip-boring-files t
             helm-net-prefer-curl t
             helm-recentf-fuzzy-match t
             helm-split-window-default-side 'other
             helm-for-files-preferred-list '(helm-source-buffers-list
                                             helm-source-bookmarks
                                             helm-source-recentf
                                             helm-source-files-in-current-dir
                                             helm-source-file-cache
                                             ;; helm-source-file-name-history
                                             helm-source-locate
                                             helm-source-find-files)
             helm-boring-file-regexp-list
             '("\\.o$"
               "~$"
               "\\.bin$"
               "\\.lbin$"
               "\\.so$"
               "\\.a$"
               "\\.ln$"
               "\\.blg$"
               "\\.bbl$"
               "\\.elc$"
               "\\.lof$"
               "\\.glo$"
               "\\.idx$"
               "\\.lot$"
               "\\.svn\\(/\\|$\\)"
               "\\.hg\\(/\\|$\\)"
               "\\.git\\(/\\|$\\)"
               "\\.bzr\\(/\\|$\\)"
               "CVS\\(/\\|$\\)"
               "_darcs\\(/\\|$\\)"
               "_MTN\\(/\\|$\\)"
               "\\.fmt$"
               "\\.tfm$"
               "\\.class$"
               "\\.fas$"
               "\\.lib$"
               "\\.mem$"
               "\\.x86f$"
               "\\.sparcf$"
               "\\.dfsl$"
               "\\.pfsl$"
               "\\.d64fsl$"
               "\\.p64fsl$"
               "\\.lx64fsl$"
               "\\.lx32fsl$"
               "\\.dx64fsl$"
               "\\.dx32fsl$"
               "\\.fx64fsl$"
               "\\.fx32fsl$"
               "\\.sx64fsl$"
               "\\.sx32fsl$"
               "\\.wx64fsl$"
               "\\.wx32fsl$"
               "\\.fasl$"
               "\\.ufsl$"
               "\\.fsl$"
               "\\.dxl$"
               "\\.lo$"
               "\\.la$"
               "\\.gmo$"
               "\\.mo$"
               "\\.toc$"
               "\\.aux$"
               "\\.cp$"
               "\\.fn$"
               "\\.ky$"
               "\\.pg$"
               "\\.tp$"
               "\\.vr$"
               "\\.cps$"
               "\\.fns$"
               "\\.kys$"
               "\\.pgs$"
               "\\.tps$"
               "\\.vrs$"
               "\\.pyc$"
               "\\.pyo$"
               "\\.egradle/sdk\\(/\\|$\\)"
               "\\.cache/mozilla\\(/\\|$\\)"
               "\\.local/share/Trash/files\\(/\\|$\\)"
               "\\.cache/\\(chromium\\|google\\-chrome\\)/Default/Cache\\(/\\|$\\)"))

       (pretty-hydra-define hydra-helm-config
         (:color teal :quit-key "q")
         ( "Files"
           (("l"     helm-locate               "locate")
            ("/"     helm-find                 "find")
            ("f"     helm-find-files           "files")
            ("p"     helm-projectile           "projectile")
            ("g"     helm-browse-project       "ls git"))
           "Search"
           (("i"     helm-semantic-or-imenu    "imenu")
            ("e"     helm-imenu-in-all-buffers "imenu all")
            ("."     helm-imenu-anywhere       "imenu any")
            ("x"     helm-rg                   "ripgrep")
            ("y"     helm-git-grep             "git grep"))
           "Browse"
           (("b"     helm-filtered-bookmarks   "Bookmark")
            ("j"     helm-list-elisp-packages  "packages")
            ("c"     helm-colors               "colours")
            ("u"     helm-ucs                  "unicode")
            ("v"     helm-atoms                "variables"))
           "Processes"
           (("h"     helm-top                  "top")
            ("k"     helm-list-emacs-process   "process")
            ("t"     helm-tramp                "tramp")
            ("s"     helm-sql-connect          "sql")
            (","     helm-calcul-expression    "calc"))
           "Help"
           (("r"     helm-resume               "resume")
            ("%"     helm-regexp               "build regex")
            ("a"     helm-apropos              "a propos")
            ("m"     helm-man-woman            "(wo)-man")
            ("B"     helm-descbinds            "bindings")))))
   #+END_SRC

   [[https://blog.burntsushi.net/ripgrep/][Ripgrep]] is the the best tool for grepping anything anywhere these days. Combined with [[https://github.com/cosmicexplorer/helm-rg][helm-rg]], it’s all I need. And it also supports editing search results from the search buffer!
   #+BEGIN_SRC emacs-lisp
     (use-package helm-rg
       :after helm
       :hook (helm-rg--bounce-mode . (lambda () (aggressive-indent-mode -1)))
       :bind ( :map helm-rg-map
               ("M-b"     . backward-word)
               ("C-c C-e" . helm-rg--bounce)
               ("M-d"   . helm-rg--set-dir)
               ("M-g"     . helm-rg--set-glob)
               :map helm-rg--bounce-mode-map
               ("C-c C-o" . helm-rg--visit-current-file-for-bounce)
               ("C-c C-e" . helm-rg--bounce))
       :config (setq helm-rg-default-directory "~"))
   #+END_SRC

   =helm-descbinds= lets me browse all user-defined keybindings.
   #+BEGIN_SRC emacs-lisp
     (use-package helm-descbinds
       :bind ("C-h b" . helm-descbinds))
   #+END_SRC

   =helm-dash= allows access to the full documentation of a language.
   #+BEGIN_SRC emacs-lisp
     (use-package helm-dash
       :after helm
       :hook
       (clojure-mode . (lambda () (setq-local helm-dash-docsets '("Clojure"))))
       (java-mode    . (lambda () (setq-local helm-dash-docsets '("Java"))))
       (js-mode      . (lambda () (setq-local helm-dash-docsets '("Javascript"))))
       (rust-mode    . (lambda () (setq-local helm-dash-docsets '("Rust"))))
       :config (setq helm-dash-browser-func 'eww))
   #+END_SRC

   =Helm-swoop= can be called during =isearch= to make searching easier with big files or big number of occurences.
   #+BEGIN_SRC emacs-lisp
     (use-package helm-swoop
       :bind ("C-S-s" . helm-swoop)
       (:map isearch-mode-map
             ;; When doing isearch, hand the word over to helm-swoop
             ("M-i" . helm-swoop-from-isearch))
       (:map helm-swoop-map
             ;; From helm-swoop to helm-multi-swoop-all
             ("M-i" . helm-multi-swoop-all-from-helm-swoop)
             ;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
             ("M-m" . helm-multi-swoop-current-mode-from-helm-swoop)
             ;; Move up and down like isearch
             ("C-r" . helm-previous-line)
             ("C-s" . helm-next-line))
       :config
       ;; Save buffer when helm-multi-swoop-edit complete
       (setq helm-multi-swoop-edit-save t

             ;; If this value is t, split window inside the current window
             helm-swoop-split-with-multiple-windows nil

             ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
             helm-swoop-split-direction 'split-window-horizontally

             ;; If nil, you can slightly boost invoke speed in exchange for text color
             helm-swoop-speed-or-color t

             ;; ;; Go to the opposite side of line from the end or beginning of line
             helm-swoop-move-to-line-cycle nil

             ;; Optional face for line numbers
             ;; Face name is `helm-swoop-line-number-face`
             helm-swoop-use-line-number-face t

             ;; If you prefer fuzzy matching
             helm-swoop-use-fuzzy-match nil))
   #+END_SRC

   Let’s enable a git-aware grep search
   #+BEGIN_SRC emacs-lisp
     (use-package helm-git-grep
       :defer t
       :after helm)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package helm-ls-git
       :after helm)
   #+END_SRC

   Let’s add a helm module to auto-complete full lines.
   #+BEGIN_SRC emacs-lisp
     (use-package helm-lines
       :commands (helm-lines))
   #+END_SRC

   Let’s add [[https://github.com/dantecatalfamo/helm-atoms][reverse variable lookup]]!
   #+BEGIN_SRC emacs-lisp
     (use-package helm-atoms
       :after helm)
   #+END_SRC

   Finally, let’s use helm for connecting to remote hosts (via TRAMP).
   #+BEGIN_SRC emacs-lisp
     (use-package helm-tramp
       :disabled
       :config
       (setq tramp-default-method "ssh"))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package ssh-config-mode
       :mode ".ssh/config$")
   #+END_SRC

** Ivy, counsel, swiper

   Once in a while, I try to use {ivy|counsel|swiper} (only to go back to helm ^^).

   Edit: that’s it, I’m moving from helm to ivy/counsel… what initiated the change was ivy-rich and the beautiful way of displaying the description next to the candidate, then the overall snappiness and feeling of solidity. I keep my helm commands for now, but almost all my use cases have been replaced so far.

   Edit: Actually I'm keeping both :D

   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :defer t
       :config
       (ivy-mode -1) ;; just like helm, I want ivy only on demand
       ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
       (setq ivy-use-virtual-buffers t)
       ;; number of result lines to display
       (setq ivy-height 20)
       ;; does not count candidates
       (setq ivy-count-format "[%d/%d] ")
       ;; no regexp by default
       (setq ivy-initial-inputs-alist nil)
       ;; configure regexp engine.
       (setq ivy-re-builders-alist
             ;; allow input not in order
             '((t . ivy--regex-ignore-order))))

     (use-package counsel
       :bind
       ("M-s <SPC>" . counsel-mark-ring)
       ("M-s a"     . counsel-apropos)
       ("M-s M-b"   . counsel-switch-buffer)
       ("M-s b"     . counsel-switch-buffer)
       ("M-s c"     . counsel-colors-emacs)
       ("M-s f"     . counsel-buffer-or-recentf)
       ("M-s g"     . counsel-rg)
       ("M-s h a"   . counsel-apropos)
       ("M-s h b"   . counsel-descbinds)
       ("M-s h c"   . counsel-describe-face)
       ("M-s h f"   . counsel-describe-function)
       ("M-s h v"   . counsel-describe-variable)
       ("M-s i"     . counsel-imenu)
       ("M-s k"     . counsel-bookmark)
       ("M-s l"     . counsel-locate)
       ("M-s p"     . counsel-package)
       ("M-s s"     . counsel-grep-or-swiper)
       ("M-s x"     . counsel-linux-app)
       ("M-s y"     . counsel-yank-pop)
       ("M-x"       . counsel-M-x))

     ;;TODO: counsel yasnippet

     (use-package counsel-dash
       :bind ("M-s d" . counsel-dash))

     (use-package counsel-projectile
       :bind ("M-s j" . counsel-projectile))

     (use-package counsel-tramp
       :bind ("M-s t" . counsel-tramp))

     (use-package counsel-web
       :bind
       ("M-s w" . counsel-web-suggest)
       ("M-s W" . counsel-web-search))

     (use-package ivy-prescient
       :after ivy
       :config (ivy-prescient-mode 1))

     (use-package all-the-icons-ivy-rich
       :init (all-the-icons-ivy-rich-mode 1))

     (use-package ivy-rich
       :init (ivy-rich-mode 1))
   #+END_SRC

** Contextual completion

   [[https://github.com/oantolin/embark/][embark]] is a sort of contextual help menu, very helpful.

   #+BEGIN_SRC emacs-lisp
     (use-package embark
       :bind
       ("M-." . embark-act)
       ("C-M-." . embark-dwim))
   #+END_SRC

   [[https://github.com/minad/marginalia][marginalia]] adds useful information in completion commands.

   #+BEGIN_SRC emacs-lisp
     (use-package marginalia
       :bind (:map minibuffer-local-map
                   ("M-A" . marginalia-cycle))
       :init (marginalia-mode))
   #+END_SRC

** Snippets
   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :commands yas-new-snippet yas-insert-snippet
       :chords ("yq" . hydra-yasnippet/body)
       :hook
       (snippet-mode . (lambda () (aggressive-indent-mode -1)))
       (text-mode . (lambda () (set (make-local-variable 'yas-indent-line) 'fixed)))
       (python-mode . (lambda () (set (make-local-variable 'yas-indent-line) 'fixed)))
       :bind
       ("<backtab>" . yas-ido-expand)
       ("C-h y" . yas-describe-tables)
       ("C-c y" . hydra-yasnippet/body)
       :config
       (setq yas-triggers-in-field t)
       (setq yas-snippet-dirs
             `(,(expand-file-name "etc/yasnippet/snippets" base-emacs-directory)
               ,(car (file-expand-wildcards
                      (expand-file-name "straight/repos/yasnippet-snippets/snippets" base-emacs-directory)))))
       (add-to-list 'yas-prompt-functions 'yas-helm-prompt)
       ;; Completing point by some yasnippet key

       (defun yas-ido-expand ()
         "Lets you select (and expand) a yasnippet key"
         (interactive)
         (let ((original-point (point)))
           (while (and
                   (not (= (point) (point-min) ))
                   (not
                    (string-match "[[:space:]\n]" (char-to-string (char-before)))))
             (backward-word 1))
           (let* ((init-word (point))
                  (word (buffer-substring init-word original-point))
                  (list (yas-active-keys)))
             (goto-char original-point)
             (let ((key (remove-if-not
                         (lambda (s) (string-match (concat "^" word) s)) list)))
               (if (= (length key) 1)
                   (setq key (pop key))
                 (setq key (ido-completing-read "key: " list nil nil word)))
               (delete-char (- init-word original-point))
               (insert key)
               (yas-expand)))))

       (defun yas-helm-prompt (prompt choices &optional display-fn)
         "Use helm to select a snippet. Put this into `yas-prompt-functions.'"
         (interactive)
         (setq display-fn (or display-fn 'identity))
         (if (require 'helm-config)
             (let (tmpsource cands result rmap)
               (setq cands (mapcar (lambda (x) (funcall display-fn x)) choices))
               (setq rmap (mapcar (lambda (x) (cons (funcall display-fn x) x)) choices))
               (setq tmpsource
                     (list
                      (cons 'name prompt)
                      (cons 'candidates cands)
                      '(action . (("Expand" . (lambda (selection) selection))))
                      ))
               (setq result (helm-other-buffer '(tmpsource) "*helm-select-yasnippet"))
               (if (null result)
                   (signal 'quit "user quit!")
                 (cdr (assoc result rmap))))
           nil))

       (pretty-hydra-define hydra-yasnippet
         (:color teal :quit-key "q")
         ("Snippet"
          (("t" yas-describe-tables "tables")
           ("r" yas-reload-all "reload"))
          "Insert"
          (("e" yas-ido-expand "ido expand")
           ("i" yas-insert-snippet "insert"))
          "Edit"
          (("n" yas-new-snippet "new")
           ("v" yas-visit-snippet-file "visit file"))
          "Auto-yasnippet"
          (("c" aya-create "create (with $, ~ or `')")
           ("a" aya-expand "apply")
           ("p" aya-persist-snippet "persist"))))
       (yas-global-mode 1))

     (use-package yasnippet-snippets
       :after yasnippet
       :config (yas-reload-all))

     (use-package auto-yasnippet
       :after yasnippet
       :config
       (setq aya-persist-snippets-dir
             (expand-file-name "etc/yasnippet/snippets" base-emacs-directory)))
   #+END_SRC

* Text manipulation
** Region
   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :bind ("C-c e" . er/expand-region))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package region-bindings-mode
       :config (region-bindings-mode-enable))
   #+END_SRC

** Point movements
   #+BEGIN_SRC emacs-lisp
     (use-package move-text
       :bind
       ("M-<down>" . move-text-down)
       ("M-<up>" . move-text-up))

     (use-package zop-to-char
       :bind ("C-M-z" . zop-up-to-char))

     (use-package selected
       :commands selected-minor-mode selected-global-mode
       :bind (:map selected-keymap
                   ("u" . upcase-region)
                   ("l" . downcase-region)
                   ("c" . capitalize-region)
                   ("u" . upcase-region)
                   ("w" . count-words-region))
       :hook ((text-mode prog-mode) . selected-global-mode))

     (use-package multiple-cursors
       :bind
       (:map region-bindings-mode-map
             ("a" . mc/mark-all-like-this) ;; new cursor on each occurence of current region
             ("d" . mc/mark-all-symbols-like-this-in-defun)
             ("D" . mc/mark-all-dwim)
             ("p" . mc/mark-previous-like-this) ;; new cursor on prev. occurence of current region
             ("n" . mc/mark-next-like-this) ;; new cursor on next occurence of current region
             ("P" . mc/unmark-previous-like-this)
             ("N" . mc/unmark-next-like-this)
             ("é" . mc/edit-lines) ;; new cursor on each line of region
             ("(" . mc/cycle-backward)
             (")" . mc/cycle-forward)
             ("m" . mc/mark-more-like-this-extended)
             ("h" . mc-hide-unmatched-lines-mode)
             ("v" . mc/vertical-align)
             ("|" . mc/vertical-align-with-space)
             ("r" . mc/reverse-regions)
             ("s" . mc/sort-regions)
             ("#" . mc/insert-numbers) ; use num prefix to set the starting number
             ("^" . mc/edit-beginnings-of-lines)
             ("$" . mc/edit-ends-of-lines)
             ("<down>" . move-text-down)
             ("<up>" . move-text-up))
       :config (setq mc/list-file (expand-file-name "var/mc-list.el" base-emacs-directory)))

     (use-package smart-comment
       :bind ("M-;" . smart-comment))

     ;; Remove text in active region if inserting text
     (pending-delete-mode t)

     ;; Allow pasting selection outside of Emacs
     (setq-default select-enable-clipboard t
                   x-select-enable-clipboard t)

     (global-set-key (kbd "M-y") 'yank-pop)
     ;; easier access to transposition commands
     (global-set-key (kbd "C-x M-h") 'transpose-paragraphs)
     (global-set-key (kbd "C-§") 'transpose-paragraphs)
     (global-set-key (kbd "C-x M-s") 'transpose-sentences)
     (global-set-key (kbd "C-x M-t") 'transpose-sexps)
   #+END_SRC

** Diffing
   #+BEGIN_SRC emacs-lisp
     (use-package ztree
       :bind (:map ztree-mode-map
                   ("o" . ztree-jump-side)
                   ("l" . recenter-top-bottom)
                   ("n" . ztree-next-line)
                   ("p" . ztree-previous-line)))
   #+END_SRC

* Buffer & window manipulation
** Windows
   Better access to window manipulation commands:
   #+BEGIN_SRC emacs-lisp
     (use-package window
       :straight nil
       :bind
       ("C-c o" . bury-buffer) ;; put buffer at bottom of buffer list
       ("C-\"" . delete-other-windows)
       ("C-«" . split-window-below)
       ("C-»" . split-window-right)
       ("C-*" . delete-window))
   #+END_SRC

   I use [[https://github.com/louiskottmann/zygospore.el][Zygospore]] to be able to revert ~delete-other-windows~:
   #+BEGIN_SRC emacs-lisp
     (use-package zygospore
       :bind ("C-x 1" . zygospore-toggle-delete-other-windows)
       ("C-\"" . zygospore-toggle-delete-other-windows))
   #+END_SRC

   Revert windows on ediff exit - needs winner mode.
   #+BEGIN_SRC emacs-lisp
     (use-package winner
       :bind
       ("<s-left>" . winner-undo)
       ("<s-right>" . winner-redo)
       :config (winner-mode))
   #+END_SRC

** Buffer Management
   Change how buffer names are made unique.
   #+BEGIN_SRC emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style 'post-forward
           uniquify-separator ":")
   #+END_SRC

   Auto-refresh all buffers.
   #+BEGIN_SRC emacs-lisp
     (use-package autorevert
       :straight nil
       :config
       (global-auto-revert-mode 1)
       (setq global-auto-revert-non-file-buffers t))
   #+END_SRC

   Some more buffer manipulation bindings.
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x M-b") 'ibuffer) ;; call ibuffer
     (global-set-key (kbd "C-x C-b") 'electric-buffer-list) ;; electric buffer by default
     (global-set-key (kbd "C-c k") 'ale/kill-this-buffer) ;; kill buffer without confirmation
     (key-chord-define-global (kbd "+-") 'ale/kill-this-buffer) ;; kill buffer without confirmation
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (pretty-hydra-define hydra-file
       (:color blue :quit-key "q")
       ("Refresh"
        (("<f5>" ale/revert-buffer-no-confirm "revert buffer"))
        "Crux commands…"
        (("f" crux-kill-buffer-truename          "copy qualified name")
         ("k" crux-kill-other-buffers            "kill other buffers")
         ("r" crux-rename-file-and-buffer        "rename")
         ("d" crux-delete-file-and-buffer        "delete")
         ("c" crux-copy-file-preserve-attributes "copy"))))
     (global-set-key (kbd "<f5>") 'hydra-file/body)
   #+END_SRC

*** ibuffer
    #+BEGIN_SRC emacs-lisp
      (use-package ibuffer
        :straight nil
        :defer t
        :hook (ibuffer-mode . (lambda ()
                                (ibuffer-auto-mode 1)
                                (ibuffer-switch-to-saved-filter-groups "default")))
        :config
        (unbind-key "M-o" ibuffer-mode-map)
        (define-ibuffer-column size-h
          (:name "Size" :inline t)
          (cond
           ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
           ((> (buffer-size) 100000)  (format "%7.0fk" (/ (buffer-size) 1000.0)))
           ((> (buffer-size) 1000)    (format "%7.1fk" (/ (buffer-size) 1000.0)))
           (t (format "%8d" (buffer-size)))))
        (setq ibuffer-formats
              '((mark modified read-only vc-status-mini " "
                      (name 35 35       :left :elide) " "
                      (size-h 9 -1      :right      ) " "
                      (mode 16 16       :left :elide) " "
                      (vc-status 14 14  :left       ) " "
                      filename-and-process)))
        (setq ibuffer-show-empty-filter-groups nil)
        (setq ibuffer-saved-filter-groups
              '(("default"
                 ("Tramp" (or (filename . "/sshx?:.+:.+")
                              (name . "\*tramp.*\*")))
                 ("Running" (and (process . "")
                                 (not (derived-mode . erc-mode))))
                 ("Text"   (and (derived-mode . text-mode)
                                (or (name . "^\\*scratch\\*\\(<[0-9]+>\\)?$")
                                    (not (name . "^\\*.+\\*$")))))
                 ("Prog" (or (derived-mode . conf-unix-mode)
                             (derived-mode . prog-mode)
                             (mode . restclient-mode)
                             (name . "\*\.\\(http\\)$")))
                 ("PDF" (or (name . "\*\.\\(pdf|PDF\\)$")
                            (mode . doc-view-mode)))
                 ("Dired" (derived-mode . dired-mode))
                 ("Helm" (or (name . "^\*helm[ -].+\*")
                             (mode . helm-rg--bounce-mode)
                             (derived-mode . helm-major-mode)))
                 ("Help" (or (mode . help-mode)
                             (mode . Info-mode)
                             (mode . helpful-mode)
                             (derived-mode . man-common)))
                 ("mu4e"  (name . "\*mu4e\*"))
                 ("Elfeed"  (name . "\*elfeed-.+\*"))
                 ("Magit" (derived-mode . magit-mode))
                 ("ERC" (derived-mode . erc-mode))
                 ("Emacs" (or (mode . diary-mode)
                              (name . "^\\*.+\\*\\(<[0-9]+>\\)?$"))))))
        (setq ibuffer-never-show-predicates
              '((lambda (buffer)
                  (when (bound-and-true-p my-ibuffer-hide-erc-buffers-p)
                    (with-current-buffer buffer (eq major-mode 'erc-mode)))))))
    #+END_SRC

*** ibuffer-vc
    #+BEGIN_SRC emacs-lisp
      (use-package ibuffer-vc
        :hook
        (ibuffer-vc-set-filter-groups-by-vc-root)
        (ibuffer-mode . (lambda ()
                          (ibuffer-vc-set-filter-groups-by-vc-root)
                          (unless (eq ibuffer-sorting-mode 'alphabetic)
                            (ibuffer-do-sort-by-alphabetic)))))
    #+END_SRC
*** Scratch
    #+BEGIN_SRC emacs-lisp
      (use-package persistent-scratch
        :config
        (persistent-scratch-setup-default)
        (defun persistent-scratch-numbered-scratch-buffer-p ()
          "Return non-nil iff the current buffer's name begins with *scratch*."
          (and (length> (buffer-name) 8)
               (string-equal "*scratch*"  (substring (buffer-name) 0 9))))
        (setq persistent-scratch-scratch-buffer-p-function
              'persistent-scratch-numbered-scratch-buffer-p))
    #+END_SRC

*** Minibuffer
    #+BEGIN_SRC emacs-lisp
      ;; C-M-e to edit minibuffer in a full-size buffer
      (use-package miniedit
        :commands minibuffer-edit
        :init (miniedit-install))
    #+END_SRC

*** Tabs
    Emacs now has a built-in tab feature. There is another package called [[https://github.com/ema2159/centaur-tabs][Centaur-tabs]]:
    #+BEGIN_SRC emacs-lisp
      (use-package centaur-tabs
        :bind
        ("C-<prior>" . centaur-tabs-backward)
        ("C-<next>" . centaur-tabs-forward)
        :config
        ;; (centaur-tabs-group-by-projectile-project)
        (centaur-tabs-group-buffer-groups)
        (setq centaur-tabs-style "rounded"
              centaur-tabs-set-modified-marker t
              centaur-tabs-modified-marker "*"
              centaur-tabs-set-icons t
              centaur-tabs-height 32)
        (defun centaur-tabs-hide-tab (x)
          (let ((name (format "%s" x)))
            (or
             (string-prefix-p "*epc" name)
             (string-prefix-p "*tramp" name)
             (string-prefix-p "*helm" name)
             (string-prefix-p "*Helm" name)
             (string-prefix-p "*Compile-Log*" name)
             (string-prefix-p "*lsp" name)
             (and (string-prefix-p "magit" name)
                  (not (file-name-extension name)))
             )))
        (centaur-tabs-group-by-projectile-project)
        ;; (defun centaur-tabs-buffer-groups ()
        ;;    "`centaur-tabs-buffer-groups' control buffers' group rules.

        ;; Group centaur-tabs with mode if buffer is derived from
        ;; `eshell-mode' `emacs-lisp-mode' `dired-mode' `org-mode' `magit-mode'.
        ;; All buffer name start with * will group to \"Emacs\".
        ;; Other buffer group by `centaur-tabs-get-group-name' with project name."
        ;;    (list
        ;;     (cond
        ;;      ;; ((not (eq (file-remote-p (buffer-file-name)) nil))
        ;;      ;; "Remote")
        ;;      ;; ((or (string-equal "*" (substring (buffer-name) 0 1))
        ;;      ;;      (memq major-mode '(magit-process-mode
        ;;      ;;                         magit-status-mode
        ;;      ;;                         magit-diff-mode
        ;;      ;;                         magit-log-mode
        ;;      ;;                         magit-file-mode
        ;;      ;;                         magit-blob-mode
        ;;      ;;                         magit-blame-mode
        ;;      ;;                         )))
        ;;      ;;  "Emacs")
        ;;      ;; ((derived-mode-p 'prog-mode)
        ;;      ;;  "Editing")
        ;;      ;; ((derived-mode-p 'dired-mode)
        ;;      ;;  "Dired")
        ;;      ;; ((memq major-mode '(helpful-mode
        ;;      ;;                     help-mode))
        ;;      ;;  "Help")
        ;;      ;; ((memq major-mode '(org-mode
        ;;      ;;                     org-agenda-clockreport-mode
        ;;      ;;                     org-src-mode
        ;;      ;;                     org-agenda-mode
        ;;      ;;                     org-beamer-mode
        ;;      ;;                     org-indent-mode
        ;;      ;;                     org-bullets-mode
        ;;      ;;                     org-cdlatex-mode
        ;;      ;;                     org-agenda-log-mode
        ;;      ;;                     diary-mode))
        ;;      ;;  "OrgMode")
        ;;      (t
        ;;       (centaur-tabs-get-group-name (current-buffer))))))
        )
    #+END_SRC

* Version control

  Always follow symbolic links for files under VC.
  #+BEGIN_SRC emacs-lisp
    (use-package vc
      :defer t
      :config (setq vc-follow-symlinks t))
  #+END_SRC

** Diff
*** vdiff
    #+BEGIN_SRC emacs-lisp
      (use-package vdiff
        :disabled
        :bind (:map vdiff-mode-map
                    ("C-c" . vdiff-mode-prefix-map))
        :init (define-key vdiff-mode-map (kbd "C-c") vdiff-mode-prefix-map)
        :config
        (setq
         ;; Whether to lock scrolling by default when starting vdiff
         vdiff-lock-scrolling t
         ;; external diff program/command to use
         vdiff-diff-program "diff"
         ;; Extra arguments to pass to diff. If this is set wrong, you may break vdiff.
         vdiff-diff-program-args ""
         ;; Commands that should be executed in other vdiff buffer to keep lines in
         ;; sync. There is no need to include commands that scroll the buffer here,
         ;; because those are handled differently.
         vdiff-mirrored-commands '(next-line
                                   previous-line
                                   beginning-of-buffer
                                   end-of-buffer)
         ;; Minimum number of lines to fold
         vdiff-fold-padding 2
         ;; Unchanged lines to leave unfolded around a fold
         vdiff-min-fold-size 4
         ;; Function that returns the string printed for a closed fold. The arguments
         ;; passed are the number of lines folded, the text on the first line, and the
         ;; width of the buffer.
         vdiff-fold-string-function 'vdiff-fold-string-default))
    #+END_SRC

*** ediff
    A saner ediff:
    #+BEGIN_SRC emacs-lisp
      (setq ediff-diff-options "-w"
            ediff-split-window-function 'split-window-vertically
            ediff-window-setup-function 'ediff-setup-windows-plain)
    #+END_SRC

*** Smerge
    #+BEGIN_SRC emacs-lisp
      (use-package smerge-mode
        :straight nil
        :bind (("M-s e" . hydra-smerge/body))
        :config
        (setq smerge-command-prefix "")
        ;; https://github.com/alphapapa/unpackaged.el#smerge-mode
        (pretty-hydra-define hydra-smerge
          (:color pink :quit-key "q" :post (smerge-auto-leave))
          ("Move"
           (("n" smerge-next "next")
            ("p" smerge-prev "prev"))
           "Keep"
           (("b" smerge-keep-base "base")
            ("u" smerge-keep-upper "upper")
            ("l" smerge-keep-lower "lower")
            ("a" smerge-keep-all "all")
            ("RET" smerge-keep-current "current"))
           "Diff"
           (("<" smerge-diff-base-upper "upper/base")
            ("=" smerge-diff-upper-lower "upper/lower")
            (">" smerge-diff-base-lower "base/lower")
            ("R" smerge-refine "Refine")
            ("e" smerge-ediff "e-diff" :color blue))
           "Other"
           (("c" smerge-combine-with-next "combine")
            ("r" smerge-resolve "resolve")
            ("k" smerge-kill-current "kill current")))))
    #+END_SRC

** Git tools
   #+BEGIN_SRC emacs-lisp
     (use-package git-timemachine :defer t)

     (use-package git-messenger
       :bind (:map git-messenger-map
                   ("d" . git-messenger:popup-diff)
                   ("s" . git-messenger:)
                   ("c" . git-messenger:copy-commit-id))
       :hook (git-messenger:popup-buffer-hook . magit-commit-mode)
       :config (setq git-messenger:show-detail t))

     (use-package gitignore-mode
       :straight (:host github :repo "magit/git-modes"
                        :files ("gitignore-mode.el"))
       :mode ".gitignore$")

     (use-package gitconfig-mode
       :straight (:host github :repo "magit/git-modes"
                        :files ("gitconfig-mode.el"))
       :mode ".gitconfig$")

     (use-package git-gutter
       :hook prog-mode
       :bind
       ("M-N" . git-gutter:next-hunk)
       ("M-P" . git-gutter:previous-hunk)
       :config
       (global-git-gutter-mode +1)
       (setq git-gutter:ask-p nil
             git-gutter:hide-gutter t))
   #+END_SRC

** Gitlab
   #+BEGIN_SRC emacs-lisp
     (use-package helm-gitlab
       :disabled
       :ensure gitlab
       :config
       (when (boundp 'my-private-gitlab-host)
         (setq gitlab-host my-private-gitlab-host))
       (when (boundp 'my-private-gitlab-username)
         (setq gitlab-username my-private-gitlab-username))
       (when (boundp 'my-private-gitlab-password)
         (setq gitlab-password my-private-gitlab-password))
       (when (boundp 'my-private-gitlab-token-id)
         (setq gitlab-token-id my-private-gitlab-token-id)))
   #+END_SRC

** Magit
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :chords ("qg" . magit-status) ;; run git status for current buffer
       :bind ("C-x g" . hydra-git/body)
       :hook
       (git-commit-setup . ale/insert-ticket-prefix)
       (git-commit-setup . ale/switch-to-all-dict)
       :custom-face (magit-branch-current ((t ( :foreground "#5cEfFF"
                                                :box ( :line-width (3 . 3)
                                                       :color "#ee0000"
                                                       :style released-button)))))
       :config
       (put 'magit-edit-line-commit 'disabled nil)
       (pretty-hydra-define hydra-git
         (:color blue :quit-key "q")
         ("Gutter"
          (("n" git-gutter:next-hunk "next hunk" :color pink)
           ("p" git-gutter:previous-hunk "prev hunk" :color pink)
           ("r" git-gutter:revert-hunk "revert hunk" :color pink)
           ("s" git-gutter:stage-hunk "stage hunk" :color pink)
           ("u" git-gutter-mode "gutter mode"))
          "Magit"
          (("." magit-status "status")
           ("d" magit-dispatch "dispatch…")
           ("g" magit-file-dispatch "file action…"))
          "Other"
          (("t" git-timemachine "time machine")
           ("m" git-messenger:popup-message "popup message"))))

       (use-package forge)

       (use-package magit-todos
         :config (setq magit-todos-max-items 30))

       (use-package magit-org-todos
         :config
         (magit-org-todos-autoinsert)
         (when (boundp 'my-private-work-diary-org-file)
           (setq-default magit-org-todos-filename my-private-work-diary-org-file))))
   #+END_SRC

* Project management
  I use [[https://github.com/bbatsov/helm-projectile][helm-projectile]] to manage my projects (mostly git projects).
  #+BEGIN_SRC emacs-lisp
    (use-package helm-projectile
      :delight (projectile-mode)
      :after helm
      :config
      (projectile-mode) ;; activate projectile-mode everywhere
      (helm-projectile-on)
      (setq projectile-mode-line-prefix " "
            projectile-completion-system 'helm
            projectile-require-project-root nil
            projectile-enable-caching t ;; enable caching for projectile-mode
            projectile-switch-project-action 'projectile-vc) ;; magit-status or svn
      (def-projectile-commander-method ?d
        "Open project root in dired."
        (projectile-dired))
      (def-projectile-commander-method ?f
        "Git fetch."
        (magit-status)
        (call-interactively #'magit-fetch-current)))
  #+END_SRC

* Tramp

  #+BEGIN_SRC emacs-lisp
    (use-package tramp
      :straight nil
      :defer t
      :config
      (setq remote-file-name-inhibit-cache nil ;; cache file-name forever
            tramp-verbose 1 ;; only log errors
            tramp-syntax 'default
            ;; make sure vc stuff is not making tramp slower
            vc-ignore-dir-regexp (format "%s\\|%s"
                                         vc-ignore-dir-regexp
                                         tramp-file-name-regexp)))
  #+END_SRC

* Date
  Date and time should be displayed in standard format, no M/D/Y nonsense.
  #+BEGIN_SRC emacs-lisp
    (use-package time
      :straight nil
      :config
      (setq display-time-day-and-date t ;; display date and time
            display-time-24hr-format t ;; 24h time format
            european-calendar-style t ;; day/month/year format for calendar
            calendar-week-start-day 1 ;; start week on Monday
            display-time-string-forms '((if (and (not display-time-format)
                                                 display-time-day-and-date)
                                            (format-time-string "%H:%M" now))))
      (display-time))
  #+END_SRC

  Add a hydra to insert the current date (and time) in various formats.
  #+BEGIN_SRC emacs-lisp
    (pretty-hydra-define hydra-dates
      (:color blue :quit-key "q")
      ("Insert date"
       (("s" ab/date-short (format-time-string "%d/%m/%Y"))
        ("d" ab/date-iso (format-time-string "%F"))
        ("D" ab/date-iso-with-day (format-time-string "%F %A"))
        ("l" ab/date-long (format-time-string "%d %B %Y"))
        ("L" ab/date-long-with-day (format-time-string "%A %d %B %Y"))
        ("o" ale/org-date (format-time-string "<%F %a>")))
       "Insert date & time"
       (("t" ab/date-short-with-time (format-time-string "%Y/%m/%d %H:%M"))
        ("T" ab/date-long-with-time (format-time-string "%A %d %B %Y - %H:%M") :width 33)
        ("i" ab/date-iso-with-time (format-time-string "%FT%T%z"))
        ("x" crux-insert-date "crux format")
        ("O" ale/org-date-time (format-time-string "<%F %a %H:%M>")))
       "Go to"
       (("g" ale/org-diary-goto-today (format-time-string "%F")))))

    (global-set-key (kbd "C-c d") 'hydra-dates/body)
  #+END_SRC

  I use [[https://github.com/kiwanami/emacs-calfw][calfw]] for a nice display of calendars.
  #+BEGIN_SRC emacs-lisp
    (use-package calfw
      :commands open-calendar
      :config
      ;; Unicode characters
      (setq cfw:fchar-junction ?╋
            cfw:fchar-vertical-line ?┃
            cfw:fchar-horizontal-line ?━
            cfw:fchar-left-junction ?┣
            cfw:fchar-right-junction ?┫
            cfw:fchar-top-junction ?┯
            cfw:fchar-top-left-corner ?┏
            cfw:fchar-top-right-corner ?┓)
      (defun open-calendar ()
        (interactive)
        (cfw:open-calendar-buffer
         :contents-sources
         (list
          (cfw:ical-create-source
           "Perso"
           my-private-personal-ical-url
           "RoyalBlue")
          (cfw:org-create-source
           "grey50") ; orgmode source
          (cfw:ical-create-source
           "Vacances"
           "https://www.data.gouv.fr/fr/datasets/r/17254f2a-a611-4b1f-995c-df45a4570f12"
           "goldenrod") ; ICS source1
          (cfw:ical-create-source
           "Moon"
           "http://cantonbecker.com/astronomy-calendar/astrocal.ics"
           "gray20"))))

      (use-package calfw-cal)
      (use-package calfw-ical)
      (use-package calfw-org))
  #+END_SRC

* Text
  #+BEGIN_SRC emacs-lisp
    (use-package text-mode
      :straight nil
      :hook (text-mode . visual-line-mode) ;; auto-wrapping (soft wrap) in text-mode
      :config
      (setq default-major-mode 'text-mode) ;; text-mode by default
      (remove-hook 'text-mode-hook #'turn-on-auto-fill)) ;; visual-line-mode instead of auto-fill)
  #+END_SRC

  Sometimes CSV mode can be useful:
  #+BEGIN_SRC emacs-lisp
    (use-package csv-mode
      :mode ("\\.csv\\'")
      :config (setq csv-separators '("," "	" ";")))
  #+END_SRC

  AsciiDoc is another markup language.
  #+BEGIN_SRC emacs-lisp
    (use-package adoc-mode
      :mode
      ("\\.asciidoc\\'" . adoc-mode)
      ("\\.adoc" . adoc-mode))
  #+END_SRC

* Org-mode
  #+BEGIN_SRC emacs-lisp
    (use-package org
      :init (setq org-refile-targets nil
                  org-capture-templates '())
      :bind (("C-c a" . org-agenda)
             ("C-c b" . org-iswitchb)
             ("C-c l" . org-store-link)
             :map org-mode-map
             ("C-c +" . increment-number-decimal)
             ("C-c -" . decrement-number-decimal)
             ("C-c j" . ale/jirify)
             ("C-c r" . ale/rtify)
             ("C-c t" . org-begin-template))
      :chords ("gx" . org-capture)
      :hook (org-mode . visual-line-mode)
      :custom-face
      (org-agenda-date
       ((t ( :foreground "#a991f1"
             :inverse-video nil
             :box ( :line-width (2 . 2)
                    :color "grey75"
                    :style released-button)
             :weight ultra-bold))))
      (org-agenda-date-today
       ((t ( :foreground "#a991f1"
             :inverse-video t
             :box ( :line-width (2 . 2)
                    :color "grey75"
                    :style released-button)
             :weight ultra-bold))))
      (org-agenda-date-weekend
       ((t ( :foreground "#68228b"
             :inverse-video nil
             :box ( :line-width (1 . 1)
                    :color "grey75"
                    :style released-button)
             :weight ultra-bold))))
      (org-done
       ((t ( :foreground "PaleGreen"
             :weight bold))))
      (org-headline-done
       ((((class color) (min-colors 16) (background dark))
         ( :foreground "dim grey"
           :strike-through t))))
      :config
      (unbind-key "C-c C-j" org-mode-map)
      (require 'ox-md nil t)
      (require 'org-agenda)
      (remove-hook 'text-mode-hook #'turn-on-auto-fill) ;; visual-line-mode instead of auto-fill

      (require 'color)

      ;; general settings
      (setq org-hide-emphasis-markers t
            org-adapt-indentation t
            org-tags-column -80
            org-ellipsis " ▼")

      ;; org log
      (setq org-log-done 'time
            org-log-repeat 'nil)

      ;; org-agenda
      (setq diary-local-file
            (if (boundp 'my-private-local-diary-file)
                my-private-local-diary-file
              (expand-file-name "diary.org" base-emacs-directory))
            todo-local-file
            (if (boundp 'my-private-local-todo-org-file)
                my-private-local-todo-org-file
              (expand-file-name "todo.org" base-emacs-directory))
            todo-notes-file
            (if (boundp 'my-private-local-notes-org-file)
                my-private-local-notes-org-file
              (expand-file-name "notes.org" base-emacs-directory))
            todo-media-file
            (if (boundp 'my-private-local-media-org-file)
                my-private-local-media-org-file
              (expand-file-name "media.org" base-emacs-directory))
            org-finished-file
            (if (boundp 'my-private-local-finished-org-file)
                my-private-local-finished-org-file
              (expand-file-name "finished.org" base-emacs-directory)))

      (setq org-agenda-files (if (boundp 'my-org-agenda-files) my-org-agenda-files nil))

      (setq org-agenda-include-diary t
            org-agenda-weekend-days '(0 5 6)
            ;; week-end is friday, saturday, sunday
            org-agenda-start-day nil
            org-agenda-start-on-weekday 1
            ;; org-agenda-start-on-weekday nil
            org-agenda-span 'week
            org-agenda-entry-text-maxlines 15)

      ;; refile and completion
      (setq org-completion-use-ido nil
            org-refile-targets '((nil :maxlevel . 2)
                                 (org-finished-file :maxlevel . 2)
                                 (org-agenda-files :maxlevel . 2))
            org-refile-use-outline-path 'file
            org-outline-path-complete-in-steps nil
            org-refile-allow-creating-parent-nodes 'confirm
            org-completing-read 'helm--completing-read-default)

      (setq org-agenda-custom-commands
            '(("e" "Work only"
               ((org-super-agenda-mode -1)
                (agenda ""
                        ((org-agenda-span 3)
                         (tags "enercoop")))))
              ("i" "Agenda + important TODOs"
               ((agenda #1="")
                (tags-todo "+PRIORITY=\"A\"")
                (alltodo #1#)))
              ("n" "Agenda and all TODOs"
               ((agenda #1="")
                (alltodo #1#)))
              ("w" "Weekly Review"
               ((agenda ""
                        ((org-agenda-span 7))) ; review upcoming deadlines and appointments
                                            ; type "l" in the agenda to review logged items
                (stuck "")         ; review stuck projects as designated by org-stuck-projects
                (todo "PROJECT")   ; review all projects
                (todo "MAYBE")     ; review someday/maybe items
                (todo "WAITING"))) ; review waiting items
              ;; ...other commands here
              ("E" "Emacs TODOs"
               ((tags-todo "emacs")))))

      ;; new lines and separators
      (setq org-blank-before-new-entry
            '((heading . auto)
              (plain-list-item . auto))
            org-cycle-separator-lines 2)

      ;; html export
      (setq org-export-html-style-include-scripts nil
            org-export-html-style-include-default nil
            org-html-htmlize-output-type 'css
            org-export-html-style "<link rel=\"stylesheet\" type=\"text/css\" href=\"org.css\" />"
            org-export-coding-system 'utf-8
            org-src-ask-before-returning-to-edit-buffer nil
            org-src-window-setup 'current-window

            ;; active Babel languages
            org-confirm-babel-evaluate nil)

      (org-babel-do-load-languages 'org-babel-load-languages
                                   '((shell . t)
                                     ;; (ledger . t)
                                     (sql . t)
                                     (dot . t)
                                     ;; (restclient . t)
                                     (emacs-lisp . t)))
      ;; ORG-CAPTURE
      (defun add-property-with-date-captured ()
        "Add CREATED property to the current item."
        (interactive)
        (org-set-property "CREATED" (format-time-string "[%F %a %R]")))
      (add-hook 'org-capture-before-finalize-hook 'add-property-with-date-captured)

      ;; LOCAL
      (add-to-list 'org-capture-templates
                   '("b" "Book" ;; add a book in to-read list
                     entry (file+headline todo-media-file "Lecture")
                     "* LIRE %i%?%^{Author}p%^{Date}p"
                     :prepend t :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("f" "Film\n" ;; add a film in to-watch list
                     entry (file+headline todo-media-file "Films")
                     "* VOIR %i%?%^{Date}p"
                     :prepend t :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("E" "Emprunt" ;; add a borrow entry
                     entry (file+headline  todo-local-file "À rendre")
                     "* RENDRE %i%?"
                     :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("p" "Prêt\n" ;; add a lend entry
                     entry (file+headline  todo-local-file "À récupérer")
                     "* RÉCUPÉRER %i%?"
                     :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("t" "TODO" ;; add a TODO entry
                     entry (file todo-local-file)
                     "* TODO %i%?\n%a\n"
                     :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("T" "TODO - avec date" ;; add a TODO entry
                     entry (file todo-local-file)
                     "* TODO %i%?\n\tSCHEDULED: %t\n%a\n"
                     :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("d" "Diary - today" ;; add a diary entry
                     item (file+olp+datetree diary-local-file)
                     "\t%i%?"
                     :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("D" "Diary" ;; add a diary entry
                     item (file+olp+datetree diary-local-file)
                     "\t%i%?"
                     :time-prompt t :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("i" "Idée" ;; add an idea entry
                     item (file+headline todo-notes-file "Pêle-mêle")
                     "%i%?"
                     :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("y" "snippet\n" ;; add a (code) snippet
                     entry (file+headline todo-notes-file "Code snippets")
                     "* %?\n\t#+BEGIN_SRC \n%i\n\t#+END_SRC\n"
                     :kill-buffer t) t)

      (add-to-list 'org-capture-templates
                   '("e" "todo in Emacs\n" ;; add a todo entry for emacs
                     entry (file+headline todo-local-file "Emacs")
                     "* TODO %?"
                     :kill-buffer t) t)

      (when (and (boundp 'my-private-work-diary-org-file)
                 (boundp 'my-work-machine-name)
                 (equal my-work-machine-name (system-name)))
        (add-to-list 'org-capture-templates
                     '("l" "Log       (work)"
                       entry (file+olp+datetree my-private-work-diary-org-file)
                       "* TODO %i%?\n\tSCHEDULED: %t\n%a\n"
                       :time-prompt t :kill-buffer t) t)
        (add-to-list 'org-capture-templates
                     '("w" "TODO      (work)"
                       entry (file+headline my-private-work-diary-org-file "À faire")
                       "* TODO %i%?\n\tSCHEDULED: %t\n%a\n"
                       :prepend t :kill-buffer t) t)
        (add-to-list 'org-capture-templates
                     '("v" "Revue     (work)"
                       entry (file+headline my-private-work-diary-org-file "À faire")
                       "* Review %i%?\n\tSCHEDULED: %t"
                       :prepend t :kill-buffer t) t)
        (add-to-list 'org-capture-templates
                     '("r" "Référence (work)\n"
                       entry (file+headline my-private-work-diary-org-file "Références")
                       "* %?\n%i"
                       :prepend t :kill-buffer t) t))

      ;; font and faces customization
      (setq org-fontify-done-headline t)
      (setq org-todo-keyword-faces
            '(("TODO"       . (:foreground "#Ffc0cb" :weight bold))
              ("MÉMO"       . (:foreground "#Ffc0cb" :weight bold))
              ("NEXT"       . (:foreground "#Ffc0cb" :weight bold))
              ("LIRE"       . (:foreground "#Ffc0cb" :weight bold))
              ("VOIR"       . (:foreground "#Ffc0cb" :weight bold))
              ("ÉCOUTER"    . (:foreground "#Ffc0cb" :weight bold))
              ("EMPRUNT"    . (:foreground "#Ffc0cb" :weight bold))
              ("RENDRE"     . (:foreground "#Ffc0cb" :weight bold))
              ("PRÊT"       . (:foreground "#Ffc0cb" :weight bold))
              ("RÉCUPÉRER"  . (:foreground "#Ffc0cb" :weight bold))
              ("PROJET"     . (:foreground "#Eea9b8" :weight bold))
              ("PROJECT"    . (:foreground "#Eea9b8" :weight bold))
              ("MAYBE"      . (:foreground "#Cd919e" :weight bold))
              ("WAIT"       . (:foreground "#8b636c" :weight bold))
              ("BLOQUÉ"     . (:foreground "#Ffa500" :weight bold))
              ("BLOCKED"    . (:foreground "#Ffa500" :weight bold))
              ("INPROGRESS" . (:foreground "yellow"  :weight bold))
              ("INPR"       . (:foreground "yellow"  :weight bold))
              ("WIP"        . (:foreground "yellow"  :weight bold))
              ("STARTED"    . (:foreground "yellow"  :weight bold))
              ("DIFFÉRÉ"    . (:foreground "#1e90ff" :weight bold))
              ("DEFERRED"   . (:foreground "#1e90ff" :weight bold))
              ("DÉLÉGUÉ"    . (:foreground "#98fb98" :weight bold))
              ("DELEGATED"  . (:foreground "#98fb98" :weight bold))
              ("ABANDONNÉ"  . (:foreground "#98fb98" :weight bold))
              ("ABANDONED"  . (:foreground "#98fb98" :weight bold))
              ("ANNULÉ"     . (:foreground "#98fb98" :weight bold))
              ("CANCELLED"  . (:foreground "#98fb98" :weight bold))
              ("FAIT"       . (:foreground "#98fb98" :weight bold))
              ("DONE"       . (:foreground "#98fb98" :weight bold))))

      ;; teach french to date picker
      (setq parse-time-weekdays '(("sun" . 0)
                                  ("mon" . 1)
                                  ("tue" . 2)
                                  ("wed" . 3)
                                  ("thu" . 4)
                                  ("fri" . 5)
                                  ("sat" . 6)
                                  ("sunday" . 0)
                                  ("monday" . 1)
                                  ("tuesday" . 2)
                                  ("wednesday" . 3)
                                  ("thursday" . 4)
                                  ("friday" . 5)
                                  ("saturday" . 6)
                                  ("dim" . 0)
                                  ("lun" . 1)
                                  ("mar" . 2)
                                  ("mer" . 3)
                                  ("jeu" . 4)
                                  ("ven" . 5)
                                  ("sam" . 6)
                                  ("dimanche" . 0)
                                  ("lundi" . 1)
                                  ("mardi" . 2)
                                  ("mercredi" . 3)
                                  ("jeudi" . 4)
                                  ("vendredi" . 5)
                                  ("samedi" . 6)))
      (setq parse-time-months '(("jan" . 1)
                                ("feb" . 2)
                                ("mar" . 3)
                                ("apr" . 4)
                                ("may" . 5)
                                ("jun" . 6)
                                ("jul" . 7)
                                ("aug" . 8)
                                ("sep" . 9)
                                ("oct" . 10)
                                ("nov" . 11)
                                ("dec" . 12)
                                ("january" . 1)
                                ("february" . 2)
                                ("march" . 3)
                                ("april" . 4)
                                ("june" . 6)
                                ("july" . 7)
                                ("august" . 8)
                                ("september" . 9)
                                ("october" . 10)
                                ("november" . 11)
                                ("december" . 12)
                                ("fev" . 2)
                                ("fév" . 2)
                                ("avr" . 4)
                                ("mai" . 5)
                                ("jui" . 6)
                                ("juil" . 7)
                                ("aou" . 8)
                                ("sept" . 9)
                                ("déc" . 12)
                                ("janvier" . 1)
                                ("février" . 2)
                                ("fevrier" . 2)
                                ("mars" . 3)
                                ("avril" . 4)
                                ("juin" . 6)
                                ("juillet" . 7)
                                ("aout" . 8)
                                ("août" . 8)
                                ("septembre" . 9)
                                ("octobre" . 10)
                                ("novembre" . 11)
                                ("décembre" . 12)
                                ("decembre" . 12)))

      ;; update cookies [1/2] when deleting lines
      (defun myorg-update-parent-cookie ()
        (when (equal major-mode 'org-mode)
          (save-excursion
            (ignore-errors
              (org-back-to-heading)
              (org-update-parent-todo-statistics)))))

      (defadvice org-kill-line (after fix-cookies activate)
        (myorg-update-parent-cookie))

      (defadvice kill-whole-line (after fix-cookies activate)
        (myorg-update-parent-cookie))
      (set-face-attribute 'org-block nil :background
                          (color-darken-name
                           (face-attribute 'default :background) 3)))
  #+END_SRC

  I also use a few more packages depending on org:
  #+BEGIN_SRC emacs-lisp
    (use-package ob-restclient :after org)

    (use-package verb
      :disabled ;; worth enabling only when necessary
      :after org
      :config (define-key org-mode-map (kbd "C-c C-v") verb-command-map)
      (use-package ob-verb :straight nil :after org))

    (use-package ob-shell :straight nil :after org)
    (use-package htmlize :after org)
    (use-package swagger-to-org :after org)
    (use-package ox-asciidoc :after org)
    (use-package org-tree-slide :after org)
    (use-package org-appear
      :after org
      :hook (org-mode . org-appear-mode))
  #+END_SRC

  This package allows to tangle org-files asynchronously on save by adding ~#+auto_tangle: t~ in the file header. I use it for the current file.
  #+BEGIN_SRC emacs-lisp
    (use-package org-auto-tangle
      :after org
      :hook (org-mode . org-auto-tangle-mode))
  #+END_SRC

  Display “habit” TODOs in a fancy way for the agenda view
  #+BEGIN_SRC emacs-lisp
    (use-package org-habit
      :straight nil
      :after org
      :config (setq org-habit-following-days 30
                    org-habit-preceding-days 4
                    org-habit-graph-column 65))
  #+END_SRC

  I use org-super-agenda to display relevant information in a nicer way.
  #+BEGIN_SRC emacs-lisp
    (use-package org-super-agenda
      :hook (org-agenda-mode . origami-mode)
      ;; (org-agenda-finalize . ale/org-super-agenda-origami-fold-default)
      :bind (("<f8>" . hydra-super-agenda/body)
             :map org-agenda-mode-map
             ("<tab>" . origami-toggle-node)
             :map org-super-agenda-header-map
             ("<tab>" . origami-toggle-node))
      :custom-face
      (org-super-agenda-header
       ((t ( :inherit org-agenda-structure
             :foreground "#D3d3d3"
             :overline "#778899"))))
      :config
      (defvar ale/org-super-agenda-auto-show-groups
        '("IMPORTANT" "RAPIDE" "AUJOURD’HUI" "EN COURS""EN ATTENTE"
          "TRAVAIL" "EN RETARD" "CYCLIQUES" "EMPRUNTS" "EMACS" "Other items"))
      (defun ale/org-super-agenda-origami-fold-default ()
        "Fold certain groups by default in Org Super Agenda buffer."
        (forward-line 2)
        (cl-loop do (origami-forward-toggle-node (current-buffer) (point))
                 while (origami-forward-fold-same-level (current-buffer) (point)))
        (--each ale/org-super-agenda-auto-show-groups
          (goto-char (point-min))
          (when (re-search-forward (rx-to-string `(seq bol " " ,it)) nil t)
            (origami-show-node (current-buffer) (point)))))
      (setq super-groups-main
            '(;; Each group has an implicit boolean OR operator between its selectors.
              ;; (:name "ROUTINES"
              ;;        :order 90
              ;;        :and ( :file-path "cycliques"
              ;;               :habit t))

              (:name "PLANNING"
                     :order 5
                     :time-grid t
                     :and ( :time-grid t
                            :scheduled today)
                     :transformer map-todo-faces-super-agenda
                     :discard (:todo "DONE"))

              ;; (:name "EN COURS"
              ;;        :order 2
              ;;        :face (:foreground "yellow" :weight bold)
              ;;        :todo ("WIP" "STARTED" "DELEGATED"))

              (:name "EN ATTENTE"
                     :order 20
                     :face (:foreground "#8b636c")
                     :todo ("WAIT" "BLOCKED" "DEFERRED"))

              ;; on vire la catégorie, ça reste sous forme de couleur
              ;; (:name "IMPORTANT"
              ;;        :face (:foreground "red" :weight bold)
              ;;        :priority "A")

              (:name "RAPIDE"
                     :order 3
                     :face (:foreground "DeepSkyBlue" :weight bold)
                     :and ( :todo ("TODO" "NEXT" "WIP" "STARTED")
                            :effort< "15"))

              ;; (:name "TRAVAIL"
              ;;        :order 10
              ;;        :transformer map-todo-faces-super-agenda
              ;;        :and ( :todo ("TODO" "NEXT" "PROJECT")
              ;;               :scheduled t
              ;;               :not (:priority< "C")
              ;;               :tag ("enercoop" "work" "travail")))

              (:name "EN RETARD"
                     :order 4
                     :face (:foreground "orange3")
                     :and ( :scheduled past
                            :todo ("TODO" "NEXT" "WIP" "STARTED" "DELEGATED")))

              (:name "PRÊTS / EMPRUNTS"
                     :order 40
                     :tag ("ÉCHANGES"))

              (:name "EMACS"
                     :order 50
                     :regexp "emacs"
                     :tag "emacs")

              (:name "DIVERS"
                     :order 80
                     :transformer map-todo-faces-super-agenda
                     :anything t)))

      (defun map-todo-faces-super-agenda (item)
        "Propertize ITEM for display in agenda."
        (cond ((string-match-p "DONE" item) item) ;; no special face for done items
              ((string-match-p "WAIT\\|BLOQUÉ\\|DEFERRED\\|BLOCKED" item)
               (propertize item 'face '(:foreground "#8b636c")))
              ((string-match-p "WIP\\|STARTED\\|DELEGATED" item)
               (propertize item 'face '(:foreground "yellow")))
              ((string-match-p "\\[#A\\]" item)
               (propertize item 'face '(:foreground "red" :weight bold)))
              ((string-match-p "\\[#C\\]\\|\\[#D\\]\\|\\[#E\\]" item)
               (propertize item 'face '(:foreground "#696969")))
              ;; ((string-match-p "WORK\\|enercoop" item)
              ;;  (propertize item 'face '(:foreground "#00cd00")))
              (t item)))

      (defun super-agenda (command)
        "Call the agenda COMMAND with super groups."
        (interactive)
        (setq org-super-agenda-groups super-groups-main)
        (org-super-agenda-mode 1)
        (org-agenda nil command)
        (org-agenda-day-view)
        (origami-open-all-nodes (get-buffer "*Org Agenda*")))

      (defun agenda-list (command)
        "Call the agenda for the week with COMMAND."
        (interactive)
        (org-super-agenda-mode -1)
        (org-agenda nil command)
        (org-agenda-week-view))

      (pretty-hydra-define hydra-super-agenda
        (:color teal :quit-key "q")
        ("Standard"
         (("a"    (funcall 'agenda-list "a")  "Agenda")
          ("l"    (funcall 'agenda-list "n")  "Agenda + list")
          ("t"    (funcall 'agenda-list "t")  "TODO"))
         "Custom"
         (("<f8>" (funcall 'super-agenda "a")  "Agenda + list")
          ("n"    (funcall 'super-agenda "n") "Custom + list")))))
  #+END_SRC

  Use fancy bullets in org-mode:
  #+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :after org
      :hook (org-mode . (lambda () (org-bullets-mode 1))))
  #+END_SRC

* Special characters, spelling, i18n
** Spell checking
   #+BEGIN_SRC emacs-lisp
     (use-package my-checks
       :straight nil
       :load-path "elisp/"
       :bind ("C-è" . hydra-spell/body)
       :commands dubcaps-mode
       :hook ((text-mode . flyspell-mode) ;; flyspell by default
              (text-mode . dubcaps-mode)) ;; auto-correct double capitals
       :config
       ;; Configure `LANG`, otherwise ispell.el cannot find a 'default
       ;; dictionary' even though multiple dictionaries will be configured
       ;; in next line.
       ;; (setenv "LANG" "fr_FR")
       (setq ispell-program-name "hunspell")
       (setq ispell-dictionary "fr_FR,en_GB,en_US,de_DE")
       ;; ispell-set-spellchecker-params has to be called
       ;; before ispell-hunspell-add-multi-dic will work
       (ispell-set-spellchecker-params)
       (ispell-hunspell-add-multi-dic "fr_FR,en_GB,en_US,de_DE")
       ;; For saving words to the personal dictionary, don't infer it from
       ;; the locale, otherwise it would save to ~/.hunspell_fr_FR.
       (setq ispell-personal-dictionary "~/.hunspell_personal")
       ;; The personal dictionary file has to exist, otherwise hunspell will
       ;; silently not use it.
       (unless (file-exists-p ispell-personal-dictionary)
         (write-region "" nil ispell-personal-dictionary nil 0))

       (pretty-hydra-define hydra-spell
         (:color teal :quit-key "q")
         ("Spelling"
          (("t" flyspell-mode       "toggle flyspell")
           ("T" guess-language-mode "toggle guess")
           ("g" guess-language      "guess"))
          "Flyspell"
          (("c" flyspell-buffer                 "check buffer")
           ("a" endless/ispell-word-then-abbrev "correct & add abbrev")
           ("." flyspell-auto-correct-word      "correct word"   :color pink)
           ("n" flyspell-goto-next-error        "next error"     :color pink)
           ("p" flyspell-goto-previous-error    "previous error" :color pink))
          "Dictionary"
          (("D" ispell-change-dictionary "choose" )
           ("A" ale/switch-to-all-dict   "all"    )
           ("f" ale/switch-to-fr-dict    "fr (FR)")
           ("d" ale/switch-to-de-dict    "de (DE)")
           ("e" ale/switch-to-en-dict    "en (GB)")
           ("u" ale/switch-to-us-dict    "en (US)"))
          "Look up"
          (("l" define-word-at-point                "word definition")
           ("s" powerthesaurus-lookup-word-dwim     "synonym (DWIM)")
           ("w" powerthesaurus-lookup-word          "synonym for word")
           ("S" powerthesaurus-lookup-word-at-point "synonym at point")))))

     (use-package define-word :defer t)

     (use-package guess-language :defer t)
   #+END_SRC

   I’d rather have caps-lock as a minor mode:
   #+BEGIN_SRC emacs-lisp
     (use-package caps-lock :defer t)
   #+END_SRC

** Abbrevs

   Abbrev is great in specific modes for avoiding typos.

   #+BEGIN_SRC emacs-lisp
     (use-package abbrev
       :straight nil
       :config
       (when (boundp 'my-private-abbrev-file)
         (setq abbrev-file-name my-private-abbrev-file)))
   #+END_SRC

** Synonyms
   #+BEGIN_SRC emacs-lisp
     (use-package powerthesaurus :defer t)
   #+END_SRC

** Grammalecte
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-grammalecte :defer t)
   #+END_SRC

* Programming
** Formatting
   #+BEGIN_SRC emacs-lisp
     (use-package prog-mode
       :straight nil
       :hook
       (prog-mode . (lambda () (setq show-trailing-whitespace t)))
       (prog-mode . prettify-symbols-mode)
       :config
       (setq prettify-symbols-unprettify-at-point 'right-edge)

       (defconst prettify-symbols-alist
         '(("lambda"  . ?λ)
           ("!=" . ?≠)
           ("==" . ?＝)
           ("<=" . ?⩽)
           (">=" . ?⩾)
           ("->" . ?→)
           ("<-" . ?←)
           ("=>" . ?⇒)
           ("..." . ?…)
           ("[ ]" . ?☐)
           ("[X]" . ?☑)
           ("[-]" . ?❍))))

     (use-package prog-fill
       :bind (:map prog-mode-map
                   ("M-q" . prog-fill)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package format-all :defer t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package reformatter
       :defer t
       :config (reformatter-define xml-format
                 :program "xmllint"
                 :args '("--format" "-")
                 :mode nil))
   #+END_SRC

** Flycheck
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :hook
       (prog-mode . flycheck-mode)
       (lisp-data-mode . (lambda () (add-to-list 'flycheck-disabled-checkers 'emacs-lisp-checkdoc))))
   #+END_SRC

** LSP
*** Eglot
    #+BEGIN_SRC emacs-lisp
      (use-package eglot :defer t)
    #+END_SRC

*** lsp-mode
    TODO: describe lsp
    #+BEGIN_SRC emacs-lisp
      (use-package lsp-mode
        :disabled
        :defer t
        :config
        (setq lsp-prefer-flymake nil)) ;; flycheck instead of flymake

      (use-package company-lsp
        :disabled
        :requires lsp company
        :after lsp-mode)

      (use-package lsp-ui
        :disabled
        :requires lsp-mode flycheck
        :hook (lsp-mode . lsp-ui-mode)
        :config
        (setq lsp-ui-doc-enable t
              lsp-ui-doc-use-childframe t
              lsp-ui-doc-position 'top
              lsp-ui-doc-include-signature t
              lsp-ui-sideline-enable nil
              lsp-ui-sideline-update-mode 'point
              lsp-ui-sideline-ignore-duplicate t
              lsp-ui-flycheck-enable t
              lsp-ui-flycheck-list-position 'right
              lsp-ui-flycheck-live-reporting t
              lsp-ui-peek-enable t
              lsp-ui-peek-list-width 60
              lsp-ui-peek-peek-height 25))

      (use-package helm-lsp
        :disabled
        :after lsp-mode)

      (use-package dap-mode
        :disabled
        :after lsp-mode
        :config
        (dap-mode 1)
        (dap-ui-mode 1))
    #+END_SRC

** Dealing with parens
   I tried paredit, didn’t really like the “strict” thing. Hope will get used to smartparens
   #+BEGIN_SRC emacs-lisp
     (use-package paren
       :straight nil
       :config (show-paren-mode 1)
       :custom-face (show-paren-match ((t ( :underline "white"
                                            :weight ultra-bold
                                            :background unspecified
                                            :foreground unspecified)))))

     (use-package smartparens
       :hook ((prog-mode git-commit-mode) . smartparens-mode)
       :bind (:map smartparens-mode-map
                   ;; up / down navigation
                   ("C-M-u" . sp-backward-up-sexp)
                   ("C-M-d" . sp-down-sexp)
                   ;; sexp (macro) navigation
                   ("C-M-p" . sp-backward-sexp)
                   ("C-M-n" . sp-forward-sexp)
                   ;; symbol (micro) navigation
                   ("C-M-b" . sp-backward-symbol)
                   ("C-M-f" . sp-forward-symbol)
                   ;; forward barf/slurp
                   ("C-M-(" . sp-forward-barf-sexp)
                   ("C-M-)" . sp-slurp-hybrid-sexp)
                   ;; backward barf/slurp
                   ("C-M-«" . sp-backward-slurp-sexp)
                   ("C-M-»" . sp-backward-barf-sexp)
                   ;; transformations
                   ("C-M-k" . sp-kill-hybrid-sexp)
                   ("C-M-t" . sp-transpose-sexp)
                   ("C-M-j" . sp-join-sexp)
                   ("C-M-c" . sp-clone-sexp))
       :config
       (require 'smartparens-config)
       (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
       (defmacro def-pairs (pairs)
         `(progn
            ,@(cl-loop for (key . val) in pairs
                       collect
                       `(defun ,(read (concat
                                       "wrap-with-"
                                       (prin1-to-string key t)
                                       "s"))
                            (&optional arg)
                          (interactive "p")
                          (sp-wrap-with-pair ,val)))))
       ;; (sp-local-pair 'emacs-lisp-mode "`" "'") ;; adds `' as a local pair in emacs-lisp-mode
       ;; (sp-local-pair '(tex-mode latex-mode) "{" "}") ;; adds {} as a local pair in latex-mode
       (sp-pair "<" ">")
       (sp-pair "« " " »" :trigger "«")
       (sp-pair "“" "”")
       (sp-pair "‘" "’")
       (def-pairs ((paren              . "(")
                   (bracket            . "[")
                   (brace              . "{")
                   (angle              . "<")
                   (single-quote       . "'")
                   (double-quote       . "\"")
                   (guillemet          . "« ")
                   (curly-double-quote . "“")
                   (curly-single-quote . "‘")
                   (back-quote         . "`")))
       (global-set-key (kbd "M-s (")  'wrap-with-parens)
       (global-set-key (kbd "M-s [")  'wrap-with-brackets)
       (global-set-key (kbd "M-s {")  'wrap-with-braces)
       (global-set-key (kbd "M-s <")  'wrap-with-angles)
       (global-set-key (kbd "M-s '")  'wrap-with-single-quotes)
       (global-set-key (kbd "M-s \"") 'wrap-with-double-quotes)
       (global-set-key (kbd "M-s «")  'wrap-with-guillemets)
       (global-set-key (kbd "M-s “")  'wrap-with-curly-double-quotes)
       (global-set-key (kbd "M-s ‘")  'wrap-with-curly-single-quotes)
       (global-set-key (kbd "M-s `")  'wrap-with-back-quotes)

       (pretty-hydra-define hydra-parens
         (:color teal :quit-key "q")
         ("Insert"
          (("c" sp-clone-sexp "clone")
           ("p" sp-split-sexp "split"))
          "Delete"
          (("k" sp-kill-sexp "kill")
           ("C-k" sp-kill-hybrid-sexp "kill hybrid")
           ("r" sp-raise-sexp "raise")
           ("s" sp-unwrap-sexp "unwrap")
           ("M-s" sp-splice-sexp "splice"))
          "Transform"
          (("t" sp-transpose-sexp "transpose")
           ("T" sp-transpose-hybrid-sexp "transpose hybrid")
           ("C" sp-convolute-sexp "convolute")
           ("w" sp-rewrap-sexp "rewrap")
           ("l" sp-swap-enclosing-sexp "swap enclosing"))
          "Slurp / barf"
          (("a" sp-absorb-sexp "absorb")
           ("j" sp-join-sexp "join")
           ("e" sp-emit-sexp "emit"))))
       (global-set-key (kbd "M-s M-s") 'hydra-parens/body))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package wrap-region
       :hook
       ((text-mode fundamental-mode)  . wrap-region-mode)
       :config
       (wrap-region-add-wrappers
        '(("“" "”")
          ("⩽" "⩾")
          ("‘" "’")
          ("*" "*" nil org-mode)
          ("~" "~" nil org-mode)
          ("/" "/" nil org-mode)
          ("=" "=" nil org-mode)
          ("+" "+" nil org-mode)
          ("_" "_" nil org-mode)
          ("$" "$" nil org-mode))))
   #+END_SRC

** Shell

   #+BEGIN_SRC emacs-lisp
     (use-package vterm
       :defer t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package sh-script
       :straight nil
       :hook
       (sh-mode . flycheck-mode)
       (sh-mode . (lambda () (setq tab-width 2
                              sh-basic-offset 2
                              indent-tabs-mode nil))))

     (use-package shx :defer t)
     ;;(autoload 'sh-mode "sh-mode" "Major mode for editing shell scripts." t)
     (add-to-list 'auto-mode-alist '(".*rc$" . sh-mode))
     (add-to-list 'auto-mode-alist '(".*bash.*$" . sh-mode))

     (use-package fish-mode
       :mode ("\\.fish$" . fish-mode)
       :hook (fish-mode . flycheck-mode)
       :config (setq tab-width 2
                     sh-basic-offset 2
                     fish-indent-offset 2
                     indent-tabs-mode nil))

     ;; Normal tab completion in Eshell
     (setq eshell-cmpl-cycle-completions nil)

     ;; another C-d in shell kills shell buffer
     (defun comint-delchar-or-eof-or-kill-buffer (arg)
       (interactive "p")
       (if (null (get-buffer-process (current-buffer)))
           (kill-buffer)
         (comint-delchar-or-maybe-eof arg)))

     (add-hook 'shell-mode-hook
               (lambda ()
                 (define-key shell-mode-map
                   (kbd "C-d") 'comint-delchar-or-eof-or-kill-buffer)))

     (use-package shell-pop
       :bind (:map shell-mode-map ("C-c C-l" . helm-comint-input-ring))
       :config
       (setq shell-pop-default-directory nil)
       (setq shell-pop-shell-type
             (quote ("vterm" "*vterm*" (lambda () (vterm shell-pop-term-shell)))))
       (setq shell-pop-term-shell "/bin/bash")
       ;;(setq shell-pop-universal-key "C-t")
       (setq shell-pop-window-size 30)
       (setq shell-pop-full-span t)
       (setq shell-pop-window-position "bottom")
       ;; need to do this manually or not picked up by `shell-pop'
       (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
   #+END_SRC

   Just in case, make sure we can edit with:
   #+BEGIN_QUOTE
   The One True,\\
   The Right honorable,\\
   The Standard Editor,\\
   Edward '[[https://lambdaisland.com/episodes/ultimate-dev-setup][ed(1)]]' Editor
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
     (use-package ed-mode
       :commands ed
       :straight '(ed-mode :host github
                           :repo "ryanprior/ed-mode"))
   #+END_SRC

** Powershell

   #+BEGIN_SRC emacs-lisp
     (use-package powershell
       :mode ("\\.ps1\\'" . powershell-mode)
       :config (setq powershell-indent 2))
   #+END_SRC

** Lisp

   Let’s define some behaviours for all types of lisp buffers (~lisp-data-mode~ is the parent mode for all of them).
   #+BEGIN_SRC emacs-lisp
     (use-package lisp-data-mode
       :straight nil
       :hook (lisp-data-mode . smartparens-strict-mode)
       :bind
       ("C-c C-c" . eval-region)
       ("C-c C-r" . crux-eval-and-replace))
   #+END_SRC

   Some more behaviour…
   #+BEGIN_SRC emacs-lisp
     (use-package ielm
       :straight nil
       :hook (ielm-mode . (lambda () (setq-local scroll-margin 0))))

     (use-package elisp-slime-nav
       :after emacs-lisp-mode
       :hook emacs-lisp-mode)
   #+END_SRC

   Litable mode allows quick elisp code evaluation.
   #+BEGIN_SRC emacs-lisp
     (use-package litable
       :hook (lisp-interaction-mode . litable-mode))
   #+END_SRC

   I came across [[https://github.com/hchbaw/eval-sexp-fu.el][eval-sexp-fu]] to make evaluating emacs lisp code quicker while coding.
   #+BEGIN_SRC emacs-lisp
     (use-package eval-sexp-fu
       :commands turn-on-eval-sexp-fu-flash-mode
       :hook (emacs-lisp-mode . (lambda () (turn-on-eval-sexp-fu-flash-mode)))
       :bind (:map emacs-lisp-mode-map
                   ("C-c C-c" . eval-containing-sexp)
                   ("C-x C-e" . eval-sexp-fu-eval-sexp-inner-sexp)
                   ("C-c C-r" . eval-and-replace))
       :config
       (defun eval-and-replace ()
         "Replace the preceding sexp with its value."
         (interactive)
         (let ((value (eval-sexp-fu-eval-sexp-inner-sexp)))
           (thing-at-point--end-of-sexp)
           (backward-kill-sexp)
           (insert (format "%S" value))))

       (defun eval-containing-sexp ()
         "Eval region if active, otherwise inner list as sexp."
         (interactive)
         (if (region-active-p)
             (eval-region (region-beginning) (region-end))
           (eval-sexp-fu-eval-sexp-inner-list))))
   #+END_SRC

   Redshank is a package for refactoring stuff.
   #+BEGIN_SRC emacs-lisp
     (use-package redshank
       :hook (lisp-data-mode . redshank-mode))
   #+END_SRC

** Clojure
   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :disabled
       :config
       ;; (setq cider-font-lock-dynamically nil)
       (setq cider-repl-use-pretty-printing t
             helm-cider-mode t))

     (use-package cider
       :after clojure-mode)

     (use-package helm-cider
       :after clojure-mode)
   #+END_SRC

** Sql
   #+BEGIN_SRC emacs-lisp
     (use-package sql
       :straight nil
       :bind (:map sql-mode-map
                   ("C-c C-f" . hydra-format-sql/body))
       :hook
       (sql-mode . (lambda ()
                     (setq-local truncate-lines nil)
                     (aggressive-indent-mode -1)
                     (setq-local linesize 9999)))

       (sql-interactive-mode . (lambda ()
                                 (setq-local comint-output-filter-functions 'comint-truncate-buffer)
                                 (setq-local comint-buffer-maximum-size 5000)
                                 (setq-local comint-scroll-show-maximum-output t)
                                 (setq-local comint-input-ring-size 500)))
       :mode (("\\.sql\\'" . sql-mode)
              ("\\.pks\\'" . sql-mode)
              ("\\.pkb\\'" . sql-mode)
              ("\\.mvw\\'" . sql-mode)
              ("\\.con\\'" . sql-mode)
              ("\\.ind\\'" . sql-mode)
              ("\\.sqs\\'" . sql-mode)
              ("\\.tab\\'" . sql-mode)
              ("\\.trg\\'" . sql-mode)
              ("\\.vw\\'" .  sql-mode)
              ("\\.prc\\'" . sql-mode)
              ("\\.pk\\'" .  sql-mode)))

     (use-package sqlformat :after sql)

     (use-package sql-indent :after sql)

     (use-package sql-upcase
       :straight nil
       :load-path "elisp/"
       :hook (sql-mode . sql-upcase-mode))

     (pretty-hydra-define hydra-format-sql
       (:color blue :quit-key "q")
       ("Format"
        (("f" sqlformat "paragraph")
         ("b" sqlformat-buffer "buffer")
         ("r" sqlformat-region "region")
         ("i" sql-indent-buffer "indent"))
        "Upcase"
        (("u" sql-upcase-buffer "buffer")
         ("U" sql-upcase-region "region"))))
   #+END_SRC

** Groovy
   #+BEGIN_SRC emacs-lisp
     (use-package groovy-mode
       :mode ("\\.groovy\\'" "\\.gradle\\'")
       :config (setq groovy-indent-offset 2))
   #+END_SRC

** Ruby
   #+BEGIN_SRC emacs-lisp
     (use-package ruby-mode
       :mode "\\.rb\\'"
       :interpreter "ruby")
   #+END_SRC

** Rust
   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
       :hook
       (rust-mode . cargo-minor-mode)
       (rust-mode . racer-mode)
       (racer-mode . company-mode))

     (use-package cargo
       :after rust-mode
       :config
       (add-to-list
        'exec-path
        (expand-file-name ".cargo/bin" (if (boundp 'my-home-dir) my-home-dir "~"))))

     (use-package flycheck-rust
       :after rust-mode
       :config (flycheck-rust-setup))

     (use-package racer
       :after rust-mode
       :config
       (setq company-tooltip-align-annotations t)
       ;; (setq racer-rust-src-path (expand-file-name
       ;; "/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib"
       ;; my-home-dir))
       (local-set-key (kbd "TAB") #'company-indent-or-complete-common))
   #+END_SRC

** Scala
   #+BEGIN_SRC emacs-lisp
     (use-package ensime :disabled)
     (use-package sbt-mode :disabled)
     (use-package scala-mode :disabled)
   #+END_SRC

** Java
   Enable flycheck for Java:
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-java ;; flycheck minor mode for java
       :disabled
       :straight '(flycheck-java
                   :host github
                   :repo "akorobov/flycheck-java")
       :hook java-mode)
   #+END_SRC

*** TODO malabar-mode (à tester)
    #+BEGIN_SRC emacs-lisp
      (use-package malabar-mode
        :disabled
        :hook
        (after-init . (lambda () (message "activate-malabar-mode") (activate-malabar-mode)))
        (malabar-java-mode . flycheck-mode)
        (malabar-groovy-mode . flycheck-mode)
        (malabar-mode . (lambda () (progn
                                (add-hook 'after-save-hook 'malabar-http-compile-file-silently nil t)
                                (add-hook 'after-save-hook 'malabar-compile-file-silently nil t))))
        :config
        ;; JAVA (malabar-mode)
        ;; mimic the IDEish compile-on-save behaviour
        ;; (load-file "~/outils/cedet/cedet-devel-load.el")
        (load-file "~/projets/malabar-mode/src/main/lisp/malabar-mode.el")
        (load-file "~/projets/cedet/cedet-devel-load.el"))
    #+END_SRC

*** TODO eclim (à tester)
    #+BEGIN_SRC emacs-lisp
      (use-package eclim
        :disabled
        :hook
        (java-mode . (lambda () (setq flycheck-java-ecj-jar-path "~/outils/java/ecj-4.5.jar")))
        (java-mode . eclim-mode)
        :config
        (global-eclim-mode)
        (require 'eclimd)
        (setq eclim-eclipse-dirs "~/outils/eclipse/eclipse-mars"
              eclim-executable "~/outils/eclipse/eclipse-mars/eclim")
        ;; (require 'company)
        (require 'company-emacs-eclim)
        (global-company-mode t)
        ;; (company-emacs-eclim-ignore-case t)
        (company-emacs-eclim-setup))
    #+END_SRC

*** ecb (à tester)
    #+BEGIN_SRC emacs-lisp
      (use-package ecb :disabled
        :config  (setq ecb-options-version "2.40"))
    #+END_SRC

*** lsp-java
    #+BEGIN_SRC emacs-lisp
      (use-package lsp-java
        :disabled
        ;; :delight (java-mode "🅹" :major)
        :bind ("C-S-o" . lsp-execute-code-action)
        :after lsp
        :hook (java-mode . lsp))

      (use-package dap-java
        :disabled
        :straight nil
        :after lsp-java)

      (use-package lsp-java-treemacs
        :disabled
        :straight nil
        :after treemacs)

      ;; (use-package lsp-mode
      ;;   :init (setq lsp-prefer-flymake nil)
      ;;   :demand t)

      ;; (use-package lsp-ui
      ;;   :config
      ;;   (setq lsp-ui-doc-enable nil
      ;;         lsp-ui-sideline-enable nil
      ;;         lsp-ui-flycheck-enable t)
      ;;   :after lsp-mode)

      ;; (use-package dap-mode
      ;;   :config
      ;;   (dap-mode t)
      ;;   (dap-ui-mode t))

      ;; (use-package lsp-java
      ;;   :init
      ;;   (defun java-mode-config ()
      ;;     (setq-local tab-width 4
      ;;                 c-basic-offset 4)
      ;;     (toggle-truncate-lines 1)
      ;;     (setq-local tab-width 4)
      ;;     (setq-local c-basic-offset 4)
      ;;     (lsp))

      ;;   :config
      ;;   ;; Enable dap-java
      ;;   (require 'dap-java)

      ;;   ;; Support Lombok in our projects, among other things
      ;;   (setq lsp-java-vmargs
      ;;         (list "-noverify"
      ;;               "-Xmx2G"
      ;;               "-XX:+UseG1GC"
      ;;               "-XX:+UseStringDeduplication"
      ;;               ;; (concat "-javaagent:" jmi/lombok-jar)
      ;;               ;; (concat "-Xbootclasspath/a:" jmi/lombok-jar)
      ;;               )
      ;;         lsp-file-watch-ignored
      ;;         '(".idea" ".ensime_cache" ".eunit" "node_modules"
      ;;           ".git" ".hg" ".fslckout" "_FOSSIL_"
      ;;           ".bzr" "_darcs" ".tox" ".svn" ".stack-work"
      ;;           "build")

      ;;         lsp-java-import-order '["" "java" "javax" "#"]
      ;;         ;; Don't organize imports on save
      ;;         lsp-java-save-action-organize-imports nil

      ;;         ;; Formatter profile
      ;;         ;; lsp-java-format-settings-url
      ;;         ;; (concat "file://" jmi/java-format-settings-file)
      ;;         )

      ;;   :hook (java-mode . java-mode-config)

      ;;   :demand t
      ;;   :after (lsp lsp-mode dap-mode))
    #+END_SRC

*** meghanada
    #+BEGIN_SRC emacs-lisp
      (use-package autodisass-java-bytecode
        :disabled)

      (use-package google-c-style
        :disabled
        :commands google-set-c-style)

      (use-package meghanada
        :disabled
        :commands
        (meghanada-mode)
        :bind
        (:map meghanada-mode-map
              ("M-m" . hydra-meghanada/body))
        :hook
        (java-mode . (lambda ()
                       ;; meghanada-mode on
                       (meghanada-mode t)
                       (flycheck-mode +1)
                       (setq c-basic-offset 4)))
        (before-save . meghanada-code-beautify-before-save)
        :config
        (use-package realgud ;; I don't even know what this package is or does
          :disabled)
        (setq indent-tabs-mode nil
              tab-width 4
              c-basic-offset 4
              meghanada-server-remote-debug t
              meghanada-javac-xlint "-Xlint:all,-processing"
              meghanada-java-path "java"
              meghanada-maven-path "mvn")
        :pretty-hydra
        ((:color teal :quit-key "q")
         ("Meghanada"
          (("M-m" meghanada-restart "restart")
           ("." meghanada-reference "reference")
           ("h" meghanada-typeinfo "type info"))
          "Compile"
          (("f" meghanada-compile-file "file")
           ("c" meghanada-compile-project "project"))
          "Edit"
          (("o" meghanada-optimize-import "organise imports")
           ("i" meghanada-import-all "import all")
           ("v" meghanada-local-variable))
          "Run & test"
          (("R" meghanada-run-task "run task")
           ("t" meghanada-run-junit-test-case "run JUnit test case")
           ("T" meghanada-run-junit-class "run JUnit class")
           ("r" meghanada-run-junit-recent "run JUnit recent")
           ("s" meghanada-switch-test-case "switch test case")))))

    #+END_SRC

** Javascript
   #+BEGIN_SRC emacs-lisp
     (use-package js2-mode
       ;; :bind (:js2-mode-map ("C-c C-c" . compile))
       :mode ("\\.js\\'\\|\\.json\\'" . js2-mode)
       :hook ((json-mode . json-pretty-print)
              (js2-mode . json-pretty-print-buffer)
              (js2-mode . aggressive-indent-mode)
              (js2-mode . js2-refactor-mode)
              (js2-mode . (lambda () (flycheck-mode t))))
       :config
       (use-package web-beautify
         :bind (:map js2-mode-map ("C-c C-f" . web-beautify-js)))
       (setq js2-basic-offset 2
             js-indent-level 2
             js2-use-font-lock-faces t)
       (autoload 'json-pretty-print "json-pretty-print" "json-pretty-print" t))

     (use-package js2-refactor
       :after js2-mode
       :config
       (js2r-add-keybindings-with-prefix "C-c C-r")
       (setq js2-skip-preprocessor-directives t))
     ;; à tester
     (use-package js-comint
       :disabled
       :hook
       (inferior-js-mode . (lambda ()
                             (add-hook 'comint-output-filter-functions 'js-comint-process-output)))
       (js2-mode . (lambda ()
                     (local-set-key (kbd "C-x C-e") 'js-send-last-sexp)
                     (local-set-key (kbd "C-M-x") 'js-send-last-sexp-and-go)
                     (local-set-key (kbd "C-c b") 'js-send-buffer)
                     (local-set-key (kbd "C-c C-b") 'js-send-buffer-and-go)
                     (local-set-key (kbd "C-c l") 'js-load-file-and-go))))
   #+END_SRC

** JSON
   #+BEGIN_SRC emacs-lisp
     (use-package json-mode
       :mode ("\\.json\\'"
              "\\.rasi\\'")
       :config
       (setq js-indent-level 2)
       (use-package json-reformat
         :bind (:map json-mode-map ("C-c C-f" . ale/json-reformat-region-or-buffer))
         :config (setq json-reformat:indent-width js-indent-level)))
   #+END_SRC

** Web
   #+BEGIN_SRC emacs-lisp
     (use-package web-mode ;; HTML, XML, JSP (using web-mode)
       :mode ("\\.phtml\\'"
              "\\.tpl\\.php\\'"
              "\\.[agj]sp\\'"
              "\\.as[cp]x\\'"
              "\\.erb\\'"
              "\\.js\\'"
              "\\.jsx\\'"
              "\\.mustache\\'"
              "\\.djhtml\\'"
              "\\.rhtml\\'"
              "\\.htm\\'"
              "\\.html\\'"
              "\\.tag\\'"
              "\\.tmpl\\'"
              "\\.tsx\\'"
              "\\.xml\\'"
              "\\.xsd\\'"
              "\\.wsdl\\'")
       :config
       (setq web-mode-markup-indent-offset 2
             web-mode-code-indent-offset 2
             web-mode-enable-auto-indentation t
             web-mode-enable-auto-quoting t
             web-mode-engines-alist '(("php" . "\\.phtml\\'")
                                      ("blade" . "\\.blade\\."))))

     (defun mu-xml-format ()
       "Format an XML buffer with `xmllint'."
       (interactive)
       (shell-command-on-region (point-min) (point-max)
                                "xmllint -format -"
                                (current-buffer) t
                                "*Xmllint Error Buffer*" t))
   #+END_SRC

   [[https://github.com/smihica/emmet-mode][Emmet]] is great to quickly create HTML/CSS structure
   #+BEGIN_SRC emacs-lisp
     (use-package emmet-mode
       :hook web-mode)
   #+END_SRC

   [[https://github.com/skeeto/impatient-mode][Impatient-mode]] enables live editing of html files.
   #+BEGIN_SRC emacs-lisp
     (use-package impatient-mode :defer t)
   #+END_SRC

** Typescript
   #+BEGIN_SRC emacs-lisp
     (use-package tide
       :disabled
       :chords (:map tide-mode-map
                     ("+-" . bury-buffer))
       :bind (:map tide-mode-map
                   ("C-c k" . bury-buffer)
                   ("C-." . tide-jump-to-definition)
                   ("C-," . tide-jump-back)
                   ("C-c C-c" . hydra-tide/body))
       :hook
       ;; formats the buffer before saving
       (before-save . tide-format-before-save)
       (typescript-mode . setup-tide-mode)
       (typescript-mode . rainbow-blocks-mode)
       (js2-mode . setup-tide-mode)
       :config
       (defun setup-tide-mode ()
         (interactive)
         (tide-setup)
         (flycheck-mode +1)
         (setq flycheck-check-syntax-automatically '(save mode-enabled))
         ;; flycheck-typescript-tslint-executable "tslint"
         ;; (eldoc-mode +1)
         (company-mode +1))

       (setq company-tooltip-align-annotations t  ;; aligns annotation to the right hand side
             typescript-indent-level 2
             ;; format options
             tide-format-options '(
                                   :insertSpaceAfterFunctionKeywordForAnonymousFunctions t
                                   :placeOpenBraceOnNewLineForFunctions nil))

       ;; (setq tide-tsserver-process-environment
       ;; '("TSS_LOG=-level verbose -file ~/projets/tss.log"))
       :pretty-hydra
       ((:color blue :quit-key "q")
        ("Tide"
         (("s" tide-restart-server "restart server"))
         "Edit"
         (("r" tide-rename-symbol "rename")
          ("f" tide-format "format"))
         "Navigate"
         (("e" tide-project-errors "errors")
          ("g" tide-references "references")))))

     (use-package typescript-mode
       :disabled
       :mode ("\\.ts\\'"
              "\\.json\\'"))

     (use-package sass-mode
       :mode ("\\.sass$" . sass-mode))
   #+END_SRC

** Python
   #+BEGIN_SRC emacs-lisp
     (use-package python
       :bind (:map python-mode-map
                   ("M-g M-p" . flycheck-previous-error)
                   ("M-g M-n" . flycheck-next-error)
                   ("C-x C-e" . python-shell-send-defun))
       :hook (python-mode . (lambda ()
                              (progn (aggressive-indent-mode -1)
                                     (elpy-enable)
                                     (elpy-mode)
                                     (flycheck-mode))))
       :config
       (setq python-indent-offset 4
             tab-always-indent t))

     (use-package jedi
       :after python
       :config (setq jedi:complete-on-dot t))

     (use-package elpy
       :after python
       :config
       (delete "elpy-module-flymake" elpy-modules) ;; use flycheck instead
       (setq elpy-rpc-backend "jedi")) ;; fire up jedi in python env
   #+END_SRC

** Yaml
   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :mode ("\\.yml\\'" . yaml-mode))
   #+END_SRC

** Crontab
   #+BEGIN_SRC emacs-lisp
     (use-package crontab-mode
       :mode ("crontab\\'" . crontab-mode))
   #+END_SRC

** Markdown
   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :commands (markdown-mode gfm-mode)
       :mode (("README\\.md\\'" . gfm-mode)
              ("\\.md\\'" . markdown-mode)
              ("\\.markdown\\'" . markdown-mode))
       :init (setq markdown-open-command "grip"
                   markdown-command "markdown"))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package grip-mode :defer t)
   #+END_SRC

** Dokuwiki
   #+BEGIN_SRC emacs-lisp
     (use-package dokuwiki-mode :defer t)
     (use-package dokuwiki
       :hook dokuwiki-mode)
   #+END_SRC

** LaTeX
   #+BEGIN_SRC emacs-lisp
     (use-package tex
       :mode ("\\.tex\\'")
       :straight auctex
       :config
       (use-package auctex-latexmk
         :config
         (auctex-latexmk-setup)
         (TeX-global-PDF-mode t)))
   #+END_SRC

** Gradle
   #+BEGIN_SRC emacs-lisp
     (use-package gradle-mode
       :hook groovy-mode)
   #+END_SRC

** Docker
   #+BEGIN_SRC emacs-lisp
     (use-package docker :defer t)
     (use-package dockerfile-mode
       :mode "\\DockerFile\\'")
   #+END_SRC

** Logs
   #+BEGIN_SRC emacs-lisp
     (use-package syslog-mode :defer t)
   #+END_SRC

* Mail
  #+BEGIN_SRC emacs-lisp
    (use-package sendmail
      :straight nil
      :hook (mail-mode . visual-line-mode)) ;; wrapping in mail-mode
  #+END_SRC

  Let’s use emacs to read our mail (with mu4e) :
  #+BEGIN_SRC emacs-lisp
    (use-package mu4e
      :load-path my-private-mu4e-path
      :straight nil
      :commands mu4e
      :custom-face
      (mu4e-flagged-face ((t (:foreground "gold"))))
      (mu4e-header-highlight-face ((t (;; :weight bold
                                       :background "black"
                                       ;; :foreground "red"
                                       ;; :box ( :line-width (1 . 1)
                                       ;;        :color "grey10"
                                       ;; :style released-button
                                       ))))
      :bind ( :map mu4e-view-mode-map
              ("<down>" . down-arrow)
              ("<up>" . up-arrow)
              ("{" . mu4e-view-headers-prev-unread)
              ("}" . mu4e-view-headers-next-unread)
              :map mu4e-headers-mode-map
              ("o" . mu4e-headers-change-sorting)
              ("{" . mu4e-headers-prev-unread)
              ("}" . mu4e-headers-next-unread)
              :map mu4e-main-mode-map
              ("," . mu4e-context-switch)
              ("u" . mu4e-update-mail-and-index)
              ("U" . set-update-rate)
              ("p" . previous-line)
              ("n" . next-line)
              ("Q" . mu4e-quit)
              ("q" . bury-buffer)
              ("x" . mu4e-kill-update-mail))
      :hook
      (mu4e-view-mode . visual-line-mode)
      (mu4e-compose-mode-hook . ale/switch-to-fr-dict)
      :config
      (defun set-update-rate (arg)
        "Prompt for an update rate ARG in minutes."
        (interactive "NUpdate rate in minutes: ")
        (let ((rate (prefix-numeric-value arg)))
          (setq mu4e-update-interval (* 60 rate))
          (message "Will check mail every %s minutes (after mu4e restarts)." rate)))

      (require 'org-mu4e)
      ;;store link to message if in header view, not to header query
      (setq org-mu4e-link-query-in-headers-mode nil)

      (setq mu4e-headers-unread-mark    '("u" . "📩 ")
            mu4e-headers-draft-mark     '("D" . "🚧 ")
            mu4e-headers-flagged-mark   '("F" . "🚩 ")
            mu4e-headers-new-mark       '("N" . "✨ ")
            mu4e-headers-passed-mark    '("P" . "↪ ")
            mu4e-headers-replied-mark   '("R" . "↩ ")
            mu4e-headers-seen-mark      '("S" . " ")
            mu4e-headers-trashed-mark   '("T" . "🗑️")
            mu4e-headers-attach-mark    '("a" . "📎 ")
            mu4e-headers-encrypted-mark '("x" . "🔑 ")
            mu4e-headers-signed-mark    '("s" . "🖊 "))

      (setq mu4e-maildir (expand-file-name "~/Maildir/ProtonMail")
            mu4e-attachment-dir            "~/Téléchargements"
            mu4e-drafts-folder             "/Drafts"
            mu4e-sent-folder               "/Sent"
            mu4e-trash-folder              "/Trash"
            mu4e-refile-folder             "/Archive"

            message-kill-buffer-on-exit t

            ;; Send mail
            message-send-mail-function  'smtpmail-send-it
            smtpmail-auth-credentials   my-private-auth-file
            smtpmail-smtp-server        my-private-smtp-server
            smtpmail-smtp-service       my-private-smtp-port
            mu4e-sent-messages-behavior 'sent)

      ;; signing & encrypting
      (add-hook 'message-send-hook 'mml-secure-message-sign-pgpmime)
      (setq mm-sign-option nil) ;; use default key

      ;; setup some handy shortcuts
      (setq mu4e-maildir-shortcuts
            '(("/INBOX"   . ?i)
              ("/starred" . ?s)
              ("/Drafts"  . ?d)
              ("/Sent"    . ?t)
              ("/Spam"    . ?m)
              ("/Archive" . ?a)
              ("/Gmail"   . ?g))

            ;; allow for updating mail using 'U' in the main view:
            mu4e-get-mail-command             "mbsync --all --quiet"
            mu4e-change-filenames-when-moving t ;; needed for mbsync
            mu4e-update-interval              (* 5 60) ;; update every 5 minutes
            mu4e-index-cleanup                t ;; don't do a full cleanup check
            mu4e-index-lazy-check             t ;; don't consider up-to-date dirs
            mu4e-index-update-in-background   t ;; update in the background
            mu4e-use-fancy-chars              t ;; unicode characters mess up thread drawings
            mu4e-view-show-images             t
            mu4e-headers-results-limit        200
            user-mail-address                 my-private-mail-address
            user-full-name                    my-private-full-name
            message-signature                 my-private-short-name
            mu4e-compose-signature            message-signature)

      ;; Various options for email writing
      (setq mu4e-compose-dont-reply-to-self t
            mu4e-compose-in-new-frame nil
            mu4e-compose-format-flowed nil)

      ;; Use imagemagick, if available.
      (when (fboundp 'imagemagick-register-types)
        (imagemagick-register-types))

      ;; Sometimes html email is just not readable in a text based client, this lets me open the
      ;; email in my browser.
      (setq mu4e-view-actions
            '(("capture message"  . mu4e-action-capture-message)
              ("view in browser"  . mu4e-action-view-in-browser)
              ("show this thread" . mu4e-action-show-thread)))

      (add-to-list 'mu4e-view-actions '("view in browser" . mu4e-action-view-in-browser) t)

      ;; bookmarks  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (setq mu4e-bookmarks
            '((:name "Nouveaux"         :query (concat "date:30d.."
                                                       " AND NOT %work"
                                                       " AND %unread")                  :key ?n)
              (:name "Non lus"          :query "%unread"                                :key ?u)
              (:name "Perso"            :query (concat "%unread"
                                                       " AND NOT %work")                :key ?p)
              (:name "Enercoop"         :query (concat " date:1w.."
                                                       " AND %work")                    :key ?e)
              (:name "Importants"       :query "flag:flagged"                           :key ?i)
              (:name "Récents"          :query "date:5h.. AND NOT %work"                :key ?r)
              (:name "Aujourd’hui"      :query "date:today.. AND NOT %work"             :key ?t)
              (:name "Hier"             :query "date:1d.. AND NOT %work"                :key ?h)
              (:name "Dernière semaine" :query "date:7d.. AND NOT %work" :hide-unread t :key ?w)
              (:name "Dernier mois"     :query "date:1m.. AND NOT %work" :hide-unread t :key ?m)
              (:name "Work"             :query (concat "%work"
                                                       " AND flag:unread")              :key ?e)
              ;; (:name "Avec images"   :query "mime:image/*"                :key ?i)
              ))

      ;; optimize header column sizes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (setq mu4e-headers-fields
            '((:human-date     . 11)
              (:flags          . 9)
              (:mailing-list   . 20)
              (:from-or-to     . 25)
              (:thread-subject . nil))))

    (use-package mu4e-marker-icons
      :disabled
      :config (mu4e-marker-icons-mode 1))

    (use-package mu4e-jump-to-list :after mu4e)

    (use-package helm-mu
      :after mu4e helm
      :bind ( :map mu4e-main-mode-map
              ("c" . helm-mu-contacts)
              ("C-S-s" . helm-mu)
              :map mu4e-view-mode-map
              ("c" . helm-mu-contacts)
              ("C-S-s" . helm-mu)
              :map mu4e-headers-mode-map
              ("c" . helm-mu-contacts)
              ("C-S-s" . helm-mu)))

    (use-package mu4e-query-fragments
      :after mu4e
      :config
      (setq mu4e-query-fragments-list
            '(("%unread"  . "flag:unread")
              ("%today"    . "date:today..")
              ("%junk"    . "maildir:/Junk OR subject:SPAM")
              ("%hidden"  . "flag:trashed OR %junk")
              ("%gmail"   . "maildir:/Gmail")
              ("%autos"   . "from:easter-eggs.com OR to:enercoop.org OR list:\"Coopener.enercoop.github.com\"")
              ("%encp-fw" . "maildir:/Folders/Enercoop-forward")
              ("%encp-lb" . "maildir:/Labels/Enercoop")
              ("%work"    . "%encp-fw OR %encp-lb OR %autos"))
            mu4e-query-fragments-append "AND NOT %hidden"))

    (use-package mu4e-alert
      :after mu4e
      :config
      (setq mu4e-alert-email-notification-types '(subjects)
            mu4e-alert-interesting-mail-query (concat "flag:unread" " AND maildir:/INBOX"))
      (mu4e-alert-enable-mode-line-display)
      (mu4e-alert-set-default-style 'libnotify)
      (mu4e-alert-enable-notifications))

    (use-package mu4e-maildirs-extension
      :disabled
      :after mu4e
      :config (mu4e-maildirs-extension))

    (use-package mu4e-conversation
      :disabled
      :after mu4e
      :config (global-mu4e-conversation-mode))

    (use-package mu4e-goodies
      :disabled ;TODO: à configurer
      :straight '(mu4e-goodies :host github :repo "panjie/mu4e-goodies")
      :after mu4e)
  #+END_SRC

  I send email using smtpmail. We have to make sure the gnutls command line utils are installed; package 'gnutls-bin' in Debian/Ubuntu, 'gnutls' in Archlinux.
  #+BEGIN_SRC emacs-lisp
    (use-package smtpmail
      :straight nil
      :defer t
      :config (setq message-send-mail-function 'smtpmail-send-it
                    starttls-use-gnutls t
                    smtpmail-starttls-credentials '((my-private-smtp-server my-private-smtp-port nil nil))
                    smtpmail-auth-credentials (expand-file-name my-private-auth-file)
                    smtpmail-default-smtp-server my-private-smtp-server
                    smtpmail-smtp-server my-private-smtp-server
                    smtpmail-smtp-service my-private-smtp-port
                    smtpmail-debug-info t))
  #+END_SRC

* Web browsing
  I use eww to surf the web in emacs, for simple pages mostly:
  #+BEGIN_SRC emacs-lisp
    (use-package eww
      :defer t
      :config
      (setq browse-url-generic-program my-web-browser-program ;; set default browser to eww
            browse-url-browser-function my-web-browser-function
            shr-external-browser 'browse-url-firefox ;; use ‘&’ to open page in firefox
            shr-width 100 ;; keep sane layout
            shr-use-fonts t ;; no fancy fonts in text mode
            gnus-button-url 'browse-url-generic))
  #+END_SRC

  I use [[https://github.com/jozefg/wiki-summary.el][wiki-summary]] to quickly lookup the abstract of a wikipedia entry:
  #+BEGIN_SRC emacs-lisp
    (use-package wiki-summary :defer t)
  #+END_SRC

* Quick access
** Custom menu

   Let’s define a few hydras to manage global settings. First, a general hydra for all minor modes that can be toggled:
   #+BEGIN_SRC emacs-lisp
     (pretty-hydra-define hydra-toggles
       (:color blue :quit-key "q")
       ("Navigation"
        (("B" beginend-global-mode                      "begin-end"            :toggle t)
         ("i" ido-mode                                  "ido"                  :toggle t)
         ("y" ivy-mode                                  "ivy"                  :toggle t)
         ("n" helm-mode                                 "helm"                 :toggle t)
         ("g" toggle-god-mode                           "god"                  :toggle god-local-mode)
         ("M" minimap-mode                              "minimap"              :toggle t)
         ("t" treemacs                                  "treemacs"                      )
         ("T" centaur-tabs-mode                         "tabs"                 :toggle t)
         ("W" mouse-wheel-mode                          "mouse wheel"          :toggle t))
        "Highlighting"
        (("b" beacon-mode                               "beacon"               :toggle t)
         ("C" color-identifiers-mode                    "color identifiers"    :toggle t)
         ("H" idle-highlight-mode                       "Idle HL"              :toggle t)
         ("P" prism-mode                                "prism"                :toggle t)
         ("R" rainbow-blocks-mode                       "rainbow blocks"       :toggle t)
         ("I" highlight-indent-guides-mode              "indent guide"         :toggle t)
         ("m" global-hide-mode-line-mode                "hide mode-line"       :toggle t)
         ("V" goggles-mode                              "goggles"              :toggle t))
        "Decoration"
        (;; ("G" grip-mode                              "md/org preview"       :toggle t)
         ("h" global-hl-line-mode                       "highlight line"       :toggle t)
         ;; ("D" display-battery-mode                   "display battery"      :toggle t)
         ("p" prettify-symbols-mode                     "prettify symbols"     :toggle t)
         ("e" global-emojify-mode                       "emoji"                :toggle t)
         ("j" global-fill-page-mode                     "fill-page"            :toggle t)
         ("l" global-linum-mode                         "line number"          :toggle t)
         ("r" linum-relative-global-mode                "relative line number" :toggle t)
         ("|" global-display-fill-column-indicator-mode "right margin"         :toggle t)
         ("w" global-whitespace-mode                    "whitespace"           :toggle t))
        "Coding"
        (("(" smartparens-mode                          "smartparens"          :toggle t)
         (")" smartparens-strict-mode                   "smartparens strict"   :toggle t)
         ("a" aggressive-indent-mode                    "aggressive indent"    :toggle t)
         ("A" global-auto-revert-mode                   "auto-revert"          :toggle t)
         ("c" caps-lock-mode                            "CAPS LOCK"            :toggle t)
         ;; ("c" company-mode                           "company"              :toggle t)
         ("f" flycheck-mode                             "flycheck"             :toggle t)
         ("L" litable-mode                              "litable"              :toggle t))
        "Writing"
        (("-" refill-mode                               "auto-fill"            :toggle t)
         ("v" visual-line-mode                          "visual line"          :toggle t)
         ("d" dubcaps-mode                              "dubcaps"              :toggle t)
         ("F" flyspell-mode                             "flyspell"             :toggle t)
         ("o" overwrite-mode                            "overwrite"            :toggle t)
         ("s" superword-mode                            "super-word"           :toggle t)
         ("1" ten-hundred-mode                          "1000 words"           :toggle t)
         ("z" darkroom-tentative-mode                   "darkroom"             :toggle t))))
     (global-set-key (kbd "C-é") 'hydra-toggles/body)
   #+END_SRC

   Then an other hydra for quickly switching to the major modes I use the most:
   #+BEGIN_SRC emacs-lisp
     (pretty-hydra-define hydra-major-modes
       (:color blue :quit-key "q")
       ("Lisp"
        (("e" emacs-lisp-mode "elisp")
         ("i" lisp-interaction-mode "fundamental")
         ("l" lisp-mode "lisp"))
        "Compiled"
        (("j" java-mode "Java")
         ("u" rust-mode "rust")
         ("S" sql-mode "SQL"))
        "Interpreted"
        (("g" groovy-mode "groovy")
         ("p" python-mode "python")
         ("r" ruby-mode "ruby")
         ("s" shell-script-mode "shell"))
        "Web"
        (("h" html-mode "html")
         ("c" css-mode "css")
         ("2" js2-mode "js2")
         ("n" nxml-mode "nXml")
         ("w" web-mode "web"))
        "Structured text"
        (("a" adoc-mode "ascii doc")
         ("," csv-mode "csv")
         ("m" markdown-mode "markdown")
         ("o" org-mode "org")
         ("t" text-mode "text"))))
     (global-set-key (kbd "C-c m") 'hydra-major-modes/body)
   #+END_SRC

   Finally, a last hydra to manage all kinds of stuff I use often: opening shell buffers, some specific files…
   #+BEGIN_SRC emacs-lisp
     (pretty-hydra-define hydra-widgets
       (:color blue :quit-key "q")
       ("Shells"
        (("e" (funcall (togfun "*eshell*" 'eshell)) "eshell")
         ("t" shell-pop "shell-pop")
         ("$" (funcall (togfun "*shell*" 'shell)) "shell")
         ("%" (funcall (togfun "*ansi-term*" 'crux-visit-term-buffer)) "ansi-term")
         ("v" (funcall (togfun "vterm" 'vterm)) "vterm"))
        "Navigation"
        (
         ("'" point-to-register "save bookmark")
         ("j" jump-to-register "jump to bookmark")
         ("o" crux-open-with "open")
         ("." find-file-at-point "open at point" :column "Files")
         )
        "Management"
        (("(" mu4e "mu4e")
         ("\"" erc-start-or-jump "IRC")
         ("a" (funcall 'super-agenda "a") "agenda")
         ("c" open-calendar "calendar")
         ("T" tomatinho "pomodoro")
         )
        "Diff"
        (("d" ediff "ediff")
         ("z" ztree-diff "ztree-diff")
         ("b" ale/ediff-current-buffers "quick diff")
         ("y" ale/diff-last-2-yanks "diff yanks"))
        "Tools"
        (("x" quick-calc "quick-calc")
         ;; ("n" describe-number-at-point "describe number")
         ("TAB" crux-cleanup-buffer-or-region "indent region")
         ("s" ale/cleanup-buffer-and-save "clean & save")
         ("f" ale/format-all-buffer-or-region "format all")
         ("w" webpaste-paste-region "webpaste"))
        "Emacs config"
        (("i" ale/find-init-file "init file")
         ("p p" straight-pull-all "pull packages")
         ("p c" straight-check-all "check packages")
         ("p i" straight-use-package "install package"))))

     (key-chord-define-global (kbd "bj") 'hydra-widgets/body)
     (key-chord-define-global (kbd "\"«") 'hydra-widgets/body)
   #+END_SRC

** Bookmarks and registers
   #+BEGIN_SRC emacs-lisp
     (use-package register
       :straight nil
       :chords ("jj" . jump-to-register))
   #+END_SRC

* Mode-line
  I want to be able to hide the mode-line entirely.
  #+BEGIN_SRC emacs-lisp
    (use-package hide-mode-line :defer t)
  #+END_SRC

  Aaaand we’re back to trying [[https://github.com/seagle0128/doom-modeline][doom-modeline]] this time:
  #+BEGIN_SRC emacs-lisp
    (use-package doom-modeline
      :hook (after-init . doom-modeline-mode)
      ;; :init (doom-modeline-mode 1)
      :config
      ;; How tall the mode-line should be. It's only respected in GUI.
      ;; If the actual char height is larger, it respects the actual height.
      (setq doom-modeline-height 1)

      ;; How wide the mode-line bar should be. It's only respected in GUI.
      (setq doom-modeline-bar-width 3)

      ;; The limit of the window width.
      ;; If `window-width' is smaller than the limit, some information won't be displayed.
      (setq doom-modeline-window-width-limit fill-column)

      ;; How to detect the project root.
      ;; The default priority of detection is `ffip' > `projectile' > `project'.
      ;; nil means to use `default-directory'.
      ;; The project management packages have some issues on detecting project root.
      ;; e.g. `projectile' doesn't handle symlink folders well, while `project' is unable
      ;; to hanle sub-projects.
      ;; You can specify one if you encounter the issue.
      (setq doom-modeline-project-detection 'projectile)

      ;; Determines the style used by `doom-modeline-buffer-file-name'.
      ;;
      ;; Given ~/Projects/FOSS/emacs/lisp/comint.el
      ;;   auto => emacs/lisp/comint.el (in a project) or comint.el
      ;;   truncate-upto-project => ~/P/F/emacs/lisp/comint.el
      ;;   truncate-from-project => ~/Projects/FOSS/emacs/l/comint.el
      ;;   truncate-with-project => emacs/l/comint.el
      ;;   truncate-except-project => ~/P/F/emacs/l/comint.el
      ;;   truncate-upto-root => ~/P/F/e/lisp/comint.el
      ;;   truncate-all => ~/P/F/e/l/comint.el
      ;;   relative-from-project => emacs/lisp/comint.el
      ;;   relative-to-project => lisp/comint.el
      ;;   file-name => comint.el
      ;;   buffer-name => comint.el<2> (uniquify buffer name)
      ;;
      ;; If you are experiencing the laggy issue, especially while editing remote files
      ;; with tramp, please try `file-name' style.
      ;; Please refer to https://github.com/bbatsov/projectile/issues/657.
      (setq doom-modeline-buffer-file-name-style 'auto)

      ;; Whether display icons in the mode-line. Respects `all-the-icons-color-icons'.
      ;; While using the server mode in GUI, should set the value explicitly.
      (setq doom-modeline-icon (display-graphic-p))

      ;; Whether display the icon for `major-mode'. Respects `doom-modeline-icon'.
      (setq doom-modeline-major-mode-icon t)

      ;; Whether display the colorful icon for `major-mode'.
      ;; Respects `doom-modeline-major-mode-icon'.
      (setq doom-modeline-major-mode-color-icon t)

      ;; Whether display the icon for the buffer state. It respects `doom-modeline-icon'.
      (setq doom-modeline-buffer-state-icon t)

      ;; Whether display the modification icon for the buffer.
      ;; Respects `doom-modeline-icon' and `doom-modeline-buffer-state-icon'.
      (setq doom-modeline-buffer-modification-icon t)

      ;; Whether to use unicode as a fallback (instead of ASCII) when not using icons.
      (setq doom-modeline-unicode-fallback t)

      ;; Whether display the minor modes in the mode-line.
      (setq doom-modeline-minor-modes nil)

      ;; If non-nil, a word count will be added to the selection-info modeline segment.
      (setq doom-modeline-enable-word-count t)

      ;; Major modes in which to display word count continuously.
      ;; Also applies to any derived modes. Respects `doom-modeline-enable-word-count'.
      ;; If it brings the sluggish issue, disable `doom-modeline-enable-word-count' or
      ;; remove the modes from `doom-modeline-continuous-word-count-modes'.
      ;; (setq doom-modeline-continuous-word-count-modes '(markdown-mode gfm-mode org-mode))
      (setq doom-modeline-continuous-word-count-modes nil)

      ;; Whether display the buffer encoding.
      (setq doom-modeline-buffer-encoding t)

      ;; Whether display the indentation information.
      (setq doom-modeline-indent-info nil)

      ;; If non-nil, only display one number for checker information if applicable.
      (setq doom-modeline-checker-simple-format t)

      ;; The maximum number displayed for notifications.
      (setq doom-modeline-number-limit 99)

      ;; The maximum displayed length of the branch name of version control.
      (setq doom-modeline-vcs-max-length 40)

      ;; Whether display the perspective name. Non-nil to display in the mode-line.
      (setq doom-modeline-persp-name nil)

      ;; If non nil the default perspective name is displayed in the mode-line.
      (setq doom-modeline-display-default-persp-name nil)

      ;; Whether display the `lsp' state. Non-nil to display in the mode-line.
      (setq doom-modeline-lsp t)

      ;; Whether display the GitHub notifications. It requires `ghub' package.
      (setq doom-modeline-github nil)

      ;; The interval of checking GitHub.
      (setq doom-modeline-github-interval (* 30 60))

      ;; Whether display the modal state icon.
      ;; Including `evil', `overwrite', `god', `ryo' and `xah-fly-keys', etc.
      (setq doom-modeline-modal-icon t)

      ;; Whether display the mu4e notifications. It requires `mu4e-alert' package.
      (setq doom-modeline-mu4e t)

      ;; Whether display the gnus notifications.
      (setq doom-modeline-gnus nil)

      ;; Wheter gnus should automatically be updated and how often (set to nil to disable)
      (setq doom-modeline-gnus-timer nil)

      ;; Whether display the IRC notifications. It requires `circe' or `erc' package.
      (setq doom-modeline-irc t)

      ;; Function to stylize the irc buffer names.
      (setq doom-modeline-irc-stylize 'identity)

      ;; Whether display the environment version.
      (setq doom-modeline-env-version t)
      ;; Or for individual languages
      (setq doom-modeline-env-enable-python t)
      (setq doom-modeline-env-enable-ruby   t)
      (setq doom-modeline-env-enable-perl   t)
      (setq doom-modeline-env-enable-go     t)
      (setq doom-modeline-env-enable-elixir t)
      (setq doom-modeline-env-enable-rust   t)

      ;; Change the executables to use for the language version string
      (setq doom-modeline-env-python-executable "python") ; or `python-shell-interpreter'
      (setq doom-modeline-env-ruby-executable   "ruby")
      (setq doom-modeline-env-perl-executable   "perl")
      (setq doom-modeline-env-go-executable     "go")
      (setq doom-modeline-env-elixir-executable "iex")
      (setq doom-modeline-env-rust-executable   "rustc")

      ;; What to dispaly as the version while a new one is being loaded
      (setq doom-modeline-env-load-string "...")

      ;; Hooks that run before/after the modeline version string is updated
      (setq doom-modeline-before-update-env-hook nil)
      (setq doom-modeline-after-update-env-hook nil)

      ;; I don’t want to see the battery status when it is almost full ;;;;;;
      (defun battery-more-than-p (threshold)
        "Return t if battery is charged more than a given THRESHOLD."
        (interactive)
        (< threshold
           (string-to-number
            (string-remove-suffix "%%"
                                  (prin1-to-string
                                   (cdr doom-modeline--battery-status)
                                   t)))))

      (defadvice doom-modeline-update-battery-status (after hide-full-battery activate)
        (when (battery-more-than-p 95)
          (setq doom-modeline--battery-status nil)))

      (when (daemonp)
        (add-hook 'after-make-frame-functions
                  (lambda (frame) (setq doom-modeline-icon t)))))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package poke-line
      :config
      (poke-line-global-mode 1)
      ;; https://github.com/RyanMillerC/poke-line/blob/master/docs/pokemon.md
      (setq-default poke-line-pokemon "charmander")
      (setq poke-line-minimum-window-width 64)
      (setq poke-line-bar-length 32))
  #+END_SRC

* Startup screen

  Let’s use a dashboard:
  #+BEGIN_SRC emacs-lisp
    (use-package dashboard
      :config
      (dashboard-setup-startup-hook)
      (setq dashboard-set-heading-icons t)
      (setq dashboard-set-file-icons t)
      (setq dashboard-banner-logo-title "Welcome to the real world.")
      (setq dashboard-center-content t)
      (dashboard-modify-heading-icons '((recents . "file-text")
                                        (projects . "book")
                                        (bookmarks . "book")))
      (setq dashboard-items '((recents . 8)
                              (bookmarks . 5)
                              ;; (registers . 5)
                              ;; (agenda . 10)
                              (projects . 5)))
      (setq show-week-agenda-p nil)
      (when (boundp 'my-private-footer-messages)
        (nconc dashboard-footer-messages my-private-footer-messages)))
  #+END_SRC

* Session saving & backups
  #+BEGIN_SRC emacs-lisp
    ;; auto-save file-visiting buffers
    (use-package super-save
      :disabled
      :config
      (super-save-mode +1)
      (setq super-save-auto-save-when-idle t
            auto-save-default nil))

    ;; Save a list of recent files visited.
    (use-package desktop
      :disabled
      :defer t
      :config
      (setq desktop-save t
            ;; desktop-base-lock-name      "lock"
            ;; desktop-dirname             base-emacs-directory
            ;; desktop-path                (list desktop-dirname)
            ;; desktop-files-not-to-save   "^$" ;reload tramp paths
            ;; desktop-load-locked-desktop t
            ;; (add-to-list 'desktop-modes-not-to-save 'dired-mode)
            )
      (desktop-save-mode 1)
      (desktop-read))
  #+END_SRC

* Server mode
  #+BEGIN_SRC emacs-lisp
    (use-package edit-server
      :if (and
           (display-graphic-p)
           (or
            (not (fboundp 'server-running-p))
            (not (server-running-p))))
      :bind ("M-#" . server-edit)) ;; send back to server, quicker than C-x #
  #+END_SRC

  Invoke an emacsclient to/from any input field on the system:
  #+BEGIN_SRC emacs-lisp
    (use-package emacs-everywhere :disabled)
  #+END_SRC

* Other

** Continuous integration

   #+BEGIN_SRC emacs-lisp
     ;; jenkins interaction
     (use-package butler
       :disabled
       :bind (:map butler-mode-map
                   ("n" . next-line)
                   ("p" . previous-line))
       :config
       (add-to-list 'god-exempt-major-modes 'butler-mode)
       (add-to-list 'butler-server-list
                    '(jenkins my-private-work-jenkins-url
                              (server-address . my-private-work-server-address)
                              (auth-file . my-private-work-auth-file)))) ;; machine SERVER-NAME login my_login password my_pass

     (use-package travis
       :disabled
       :defer t
       :config (setq travis--token-id my-private-work-travis-token-id
                     travis-website my-private-work-travis-website
                     travis--host my-private-work-travis-host))

     (use-package jenkins ;; TODO compare to butler
       :disabled
       :config
       (setq jenkins-api-token "<api token can be found on user's configure page>"
             jenkins-url "<jenkins url>"
             jenkins-username "<your user name>"
             jenkins-viewname "<viewname>"))
   #+END_SRC

** IRC

   I usually use irssi inside a tmux session over ssh on a distant machine so I can keep the connection alive forever. However I sometimes use ERC, and I want it configured just like my irssi session:

   #+BEGIN_SRC emacs-lisp
     (use-package erc
       :straight nil
       :hook (erc-mode . visual-line-mode)
       :bind (("<f6>" . erc-start-or-jump)
              ("C-<f6>" . erc-start-or-jump) ;; for god-mode
              :map erc-mode-map
              ("<f7>" . ale/insert-date-as-word)
              ("C-c C-x" . erc-cmd-UNTRACK-this)
              ("M-q" . erc-quote-last-message)
              ("C-o" . erc-start-or-jump))
       :config
       ;; DEFAULTS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       (setq erc-nick my-erc-nick
             erc-user-full-name my-erc-user-full-name
             erc-email-userid my-erc-email-userid)

       (setq erc-keywords my-erc-keywords)
       (setq erc-connection-alist my-erc-connection-alist)
       (setq erc-autojoin-channels-alist my-erc-autojoin-channels-alist)

       ;; BEHAVIOUR ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       (setq erc-auto-query 'bury
             erc-join-buffer 'bury)

       ;; Hide boring stuff
       (setq erc-lurker-hide-list '("JOIN" "NICK" "PART" "QUIT" "MODE"))

       ;; Kill buffers when disconnected or parted
       (setq erc-kill-buffer-on-part t
             erc-kill-queries-on-quit t
             erc-kill-server-buffer-on-quit t)

       ;; Truncate buffers to stop some sluggishness
       (setq erc-max-buffer-size 20000)
       (erc-truncate-mode t)

       ;; No default user credentials
       (setq erc-nick           nil
             erc-user-full-name nil
             erc-email-userid   nil)

       ;; APPEARANCE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       (erc-timestamp-mode t)                                          ;; timestamp
       (setq erc-timestamp-format "%R "                                ;; HH:MM
             erc-timestamp-only-if-changed-flag nil                    ;; every line
             erc-insert-timestamp-function 'erc-insert-timestamp-left) ;; on the left

       (setq erc-fill-prefix nil
             erc-fill-function 'erc-fill-variable
             erc-fill-column 500) ;; filling

       (setq erc-interpret-mirc-color t) ;; colors

       (setq erc-prompt (lambda () (concat "[" (buffer-name) "]"))) ;; prompt

       ;; LOGGING ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       (setq erc-log-insert-log-on-open nil
             erc-log-write-after-send t
             erc-log-channels t
             erc-log-channels-directory  (expand-file-name ".irclogs/" base-emacs-directory)
             erc-save-buffer-on-part t
             erc-hide-timestamps nil)
       (erc-log-mode)

       ;; Extra Mode settings

       (erc-match-mode) ;; highlight special words

       (erc-scrolltobottom-enable) ;; always try to scroll to bottom

       (use-package erc-tweet
         :config
         (defun erc-tweet-w3m-cleanup-text (tweet-text)
           (if (featurep 'w3m)
               (with-temp-buffer
                 (insert tweet-text)
                 (w3m-region (point-min) (point-max) nil 'utf8)
                 (concat (replace-regexp-in-string
                          "\n" ""
                          (buffer-substring-no-properties
                           (point-min) (point-max)))
                         "\n"))
             (erc-strip-tags tweet-text)))
         (setq erc-tweet-cleanup-text 'erc-tweet-w3m-cleanup-text)
         (add-to-list 'erc-modules 'tweet))

       (use-package erc-youtube
         :config (add-to-list 'erc-modules 'youtube))

       (use-package erc-hl-nicks)

       (use-package erc-ring
         :straight nil
         :config (erc-ring-mode t))

       (use-package erc-netsplit
         :straight nil
         :config (erc-netsplit-mode t))

       (use-package erc-spelling
         :straight nil
         :config (erc-spelling-mode 1))

       ;; Don't track boring activity
       (use-package erc-track
         :straight nil
         :config
         (erc-track-mode t)
         (setq erc-track-exclude '("*highlight") ;; ZNC highlight buffer
               erc-track-exclude-server-buffer t
               erc-track-exclude-types
               '("JOIN" "NICK" "PART" "QUIT" "MODE"
                 "324" "329" "332" "333" "353" "477")))
       ;; Custom commands
       (defun erc-start-or-jump ()
         "Connect to IRC using `erc-connection-alist' if not running,
      or jump to first active channel, or cycle through all channels."
         (interactive)
         (erc-cleanup-dead-buffers)
         (if (bound-and-true-p erc-connection-alist)
             (cl-loop for connection in erc-connection-alist
                      do (let ((irc-server   (car (cdr (assoc 'irc-server   connection))))
                               (irc-port     (car (cdr (assoc 'irc-port     connection))))
                               (irc-nick     (car (cdr (assoc 'irc-nick     connection))))
                               (irc-password (car (cdr (assoc 'irc-password connection)))))
                           (unless (erc-server-alive-p irc-server)
                             (erc :server irc-server :port irc-port :nick irc-nick :password irc-password))))
           (message "Init `erc-connection-alist' to automatically connect to servers/channels!"))
         (if erc-modified-channels-alist
             (switch-to-buffer (car (car erc-modified-channels-alist)))
           (if (eq last-command 'erc-start-or-jump)
               (next-erc-channel-buffer)
             (message "Nothing new on IRC!"))))

       (defun erc-join-channels-for-server (irc-server)
         "Join all channels for IRC-SERVER ( specified in
          `erc-autojoin-channels-alist' ) if not already joined."
         (interactive)
         (when (bound-and-true-p erc-autojoin-channels-alist)
           (cl-loop for group in erc-autojoin-channels-alist
                    when (string-suffix-p (car group) irc-server)
                    do (mapcar (lambda (chan)
                                 (when (not (member chan (car (erc-buffer-list nil))))
                                   (erc-join-channel chan))) (cdr group))

                    (cl-loop for buff in (erc-buffer-list nil)
                             do
                             (with-current-buffer buff (and (string-prefix-p irc-server (buffer-name))
                                                            (not (member chan (erc-buffer-list nil)))))
                             (with-current-buffer buff (erc-join-channel chan))))))

       (defun erc-server-alive-p (server)
         "Return non-nil if a server is alive, nil otherwise."
         (cl-loop for buff in (erc-buffer-list)
                  when (with-current-buffer buff (string-prefix-p server (buffer-name)))
                  return (erc-server-process-alive buff)))

       (defun erc-cleanup-dead-buffers ()
         "Kill ERC buffers that don’t have a live process."
         (interactive)
         (cl-loop for buff in (erc-buffer-list)
                  when (not (erc-server-process-alive buff))
                  do (progn
                       (message (concat "Cleaning up buffer " (buffer-name buff) "."))
                       (kill-buffer buff))))

       (defun next-erc-channel-buffer ()
         "Switch to an IRC buffer, or run `erc-select'.
         When called repeatedly, cycle through the buffers."
         (interactive)
         (let ((buffers (and (fboundp 'erc-buffer-list)
                             (erc-buffer-list))))
           (while (or (eq (current-buffer) (car buffers))
                      (not (erc-channel-buffer-or-query-p (car buffers))))
             (setq buffers (cdr buffers))
             (bury-buffer))
           (if buffers
               (switch-to-buffer (car buffers))
             (call-interactively 'erc-select))))

       (defun erc-channel-buffer-or-query-p (&optional buffer)
         "Return t if BUFFER (or current buffer) is an ERC channel
     or query, nil otherwise."
         (interactive)
         (with-current-buffer (or buffer (current-buffer))
           (and (eq major-mode 'erc-mode)
                (not (string-match-p "\\([^\.]+\.\\)*[^\.]+:[0-9]+" (buffer-name))))))

       (defun erc-quote-last-message (n)
         "Cite the last Nth message in current ERC channel or query."
         (interactive "p")
         (if (erc-channel-buffer-or-query-p)
             (let ((kill-read-only-ok t)
                   (count (if n n 1)))
               (goto-char (point-max))
               (when (eq last-command 'erc-quote-last-message)
                 (progn
                   (end-of-line)
                   (push-mark)
                   (beginning-of-line)
                   (let ((previous-citation
                          (substring (buffer-substring-no-properties (mark) (point)) 0 -3)))
                     (pop-mark)
                     (kill-line)
                     (setq this-command 'erc-quote-last-message)
                     (while (not (eq 0 (current-column)))
                       (search-backward previous-citation)))))
               (re-search-backward "^[0-9][0-9]:[0-9][0-9] \\(\\* .+\\|<.+>\\) .+$" nil t count)
               (push-mark)
               (end-of-line)
               (end-of-line)
               (let ((citation (buffer-substring-no-properties (mark) (point))))
                 (pop-mark)
                 (goto-char (point-max))
                 (beginning-of-line)
                 (insert (concat citation " ← "))))
           (message "Not in an ERC channel or query.")))

       (defun erc-cmd-TRACKALL ()
         "Start tracking all channels."
         (interactive)
         (setq erc-track-exclude nil))

       (defun erc-cmd-TRACK (&optional target)
         "Start tracking TARGET (or current channel)."
         (interactive)
         (let ((target (or target (buffer-name))))
           (setq erc-track-exclude (remove target erc-track-exclude))
           (message (concat "Start tracking " target "."))))

       (defun erc-cmd-UNTRACK (&optional target)
         "Stop tracking TARGET (or current channel)."
         (interactive)
         (let ((target (or target (buffer-name))))
           (setq erc-track-exclude (seq-uniq (append (list target) erc-track-exclude)))
           (message (concat "Stop tracking " target "."))))

       (defun erc-cmd-UNTRACK-this (&optional arg)
         "Stop tracking current channel. With prefix ARG, start tracking current channel."
         (interactive "P")
         (let ((target (buffer-name)))
           (if arg
               (erc-cmd-TRACK target)
             (erc-cmd-UNTRACK target))))

       (defun erc-cmd-MEDIA ()
         "Announce the current amarok song to the current ERC channel."
         (erc-cmd-ME
          (concat " is listening to "
                  (substring
                   (shell-command-to-string "mpc -f '%artist% - %title%' | head -n1")
                   0 -1))))

       (defun erc-cmd-CLEAR ()
         "Clear the current buffer."
         (erc-truncate-buffer-to-size 0))

       (defun erc-cmd-CLEARALL ()
         "Clear all ERC buffers."
         (mapc (lambda (buffer)
                 (erc-truncate-buffer-to-size 0 (get-buffer buffer)))
               (erc-all-buffer-names)))

       ;; A Bar for delimiting read and unread message
       ;; http://www.emacswiki.org/emacs/ErcBar
       (eval-after-load 'erc-track
         '(progn
            (defun erc-bar-move-back (n)
              "Moves back n message lines. Ignores wrapping, and server messages."
              (interactive "nHow many lines ? ")
              (re-search-backward "^.*<.*>" nil t n))

            (defun erc-bar-update-overlay ()
              "Update the overlay for current buffer, based on the content of
                     erc-modified-channels-alist. Should be executed on window change."
              (interactive)
              (let* ((info (assq (current-buffer) erc-modified-channels-alist))
                     (count (cadr info)))
                (if (and info (> count erc-bar-threshold))
                    (save-excursion
                      (end-of-buffer)
                      (when (erc-bar-move-back count)
                        (let ((inhibit-field-text-motion t))
                          (move-overlay erc-bar-overlay
                                        (line-beginning-position)
                                        ;; overlay on timestamp only:
                                        (+ 5 (line-beginning-position))
                                        ;; (line-end-position)
                                        (current-buffer)))))
                  (delete-overlay erc-bar-overlay))))

            (defvar erc-bar-threshold 0
              "Display bar when there are more than erc-bar-threshold unread messages.")
            (defvar erc-bar-overlay nil
              "Overlay used to set bar")
            (setq erc-bar-overlay (make-overlay 0 0))
            (overlay-put erc-bar-overlay 'face '(:overline "red"))
            ;;put the hook before erc-modified-channels-update
            (defadvice erc-track-mode (after erc-bar-setup-hook
                                             (&rest args) activate)
              ;;remove and add, so we know it's in the first place
              (remove-hook 'window-configuration-change-hook 'erc-bar-update-overlay)
              (add-hook 'window-configuration-change-hook 'erc-bar-update-overlay))
            (add-hook 'erc-send-completed-hook (lambda (str)
                                                 (erc-bar-update-overlay)))))

       ;; reload modules
       (erc-update-modules))
   #+END_SRC

** Torrent

   #+BEGIN_SRC emacs-lisp
     (use-package transmission
       :disabled
       :config
       (setq transmission-host my-private-transmission-host
             transmission-service my-private-transmission-service
             transmission-rpc-path my-private-transmission-rpc-path))
   #+END_SRC

** Accounting
   I use [[http://out.easycounter.com/external/ledger-cli.org][ledger]] to manage my money. There is a corresponding major-mode:
   #+BEGIN_SRC emacs-lisp
     (use-package ledger-mode
       :mode ("\\.dat$")
       :custom-face (ledger-font-xact-highlight-face ((t (:background "gray12"))))
       :config
       (setq ledger-clear-whole-transactions 1
             ledger-reports (("courant" "ledger ")
                             ("bal" "%(binary) -f %(ledger-file) bal")
                             ("reg" "%(binary) -f %(ledger-file) reg")
                             ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
                             ("account" "%(binary) -f %(ledger-file) reg %(account)"))))
   #+END_SRC

** Pomodoro
   #+BEGIN_SRC emacs-lisp
     (use-package tomatinho :defer t)
   #+END_SRC

** Demos
   #+BEGIN_SRC emacs-lisp
     (use-package command-log-mode :defer t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package keypression
       :defer t
       :config (setq keypression-cast-command-name t
                     keypression-fade-out-delay 1
                     keypression-fade-out-seconds 1
                     keypression-use-child-frame t
                     keypression-combine-same-keystrokes t
                     keypression-combine-format "%s ×%d"))
   #+END_SRC

** Restclient
   See if [[https://github.com/abrochard/walkman/][walkman]] might not be a bit better (because integrated in org-files!)

   #+BEGIN_SRC emacs-lisp
     (use-package restclient
       :mode (("\\.http\\'" . restclient-mode))
       :bind (:map restclient-mode-map
                   ("C-c n w" . widen)
                   ("C-c C-f" . json-mode-beautify)))

     (use-package ob-restclient :defer t)
   #+END_SRC

   [[https://github.com/flashcode/impostman][Impostman]] enables to import Postman collections/environments to use with restclient:
   #+BEGIN_SRC emacs-lisp
     (use-package impostman
       :defer t
       :straight '(impostman :host github :repo "flashcode/impostman"))
   #+END_SRC

** Web pasting
   #+BEGIN_SRC emacs-lisp
     (use-package webpaste
       :defer t
       :config
       ;; Open recently created pastes in an external browser
       (setq webpaste-open-in-browser t))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package 0x0)
   #+END_SRC

** Spritz
   [[http://spritzinc.com/][spritz]] is a reading technique. [[https://github.com/emacsmirror/spray][Spray-mode]] implements it for any emacs buffer.
   #+BEGIN_SRC emacs-lisp
     (use-package spray
       :disabled
       :bind (:map spray-mode-map
                   ("-" . spray-slower)
                   ("+" . spray-faster)
                   ("<SPC>" . spray-start/stop)
                   ("b" . spray-backward-word)
                   ("p" . spray-backward-word)
                   ("f" . spray-forward-word)
                   ("n" . spray-forward-word)))
   #+END_SRC

** epub
   It now seems possible to read epub documents (ebooks) from within emacs:
   #+BEGIN_SRC emacs-lisp
     (use-package ereader
       :mode ("\\.epub\\'" . ereader-mode))
   #+END_SRC

** Text filling
   Lorem ipsum text filler:
   #+BEGIN_SRC emacs-lisp
     (use-package lorem-ipsum :defer t)
   #+END_SRC

** Writing

   Writing simple English:
   #+BEGIN_SRC emacs-lisp
     (use-package ten-hundred-mode :defer t)
   #+END_SRC

   Zen environment for writing:
   #+BEGIN_SRC emacs-lisp
     (use-package darkroom :defer t)
   #+END_SRC

** Music
   #+BEGIN_SRC emacs-lisp
     (use-package helm-spotify-plus :disabled)
   #+END_SRC

** Videos
   #+BEGIN_SRC emacs-lisp
     (use-package ytel
       :bind (:map ytel-mode-map
                   ("<RET>" . ytel-watch))
       :config
       (defun ytel-watch ()
         "Stream video at point in mpv."
         (interactive)
         (let* ((video (ytel-get-current-video))
                (id    (ytel-video-id video))
                (url (concat "https://www.youtube.com/watch?v=" id))
                (url (concat "https://www.youtube.com/watch?v=" id)))
           (message (concat "Playing " url "…"))
           (start-process "youtube" nil
                          "smplayer"
                          url))))
   #+END_SRC

** Games
*** Typing
    #+BEGIN_SRC emacs-lisp
      (use-package speed-type :defer t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package monkeytype :defer t)
    #+END_SRC

*** Other
    #+BEGIN_SRC emacs-lisp
      (use-package 2048-game :defer t)

      (use-package vimgolf :commands vimgolf)

      (use-package slime-volleyball :defer t)

      (use-package fireplace :defer t)
    #+END_SRC

** News
*** RSS feeds
**** Avandu
     Avandu is a gateway to Tiny Tiny RSS.
     #+BEGIN_SRC emacs-lisp
       (use-package avandu
         :bind ( :map avandu-article-mode-map
                 ("p" . previous-line)
                 ("n" . next-line)
                 ("l" . recenter-top-bottom)
                 :map avandu-overview-map
                 ("<tab>" . avandu-next-feed)
                 ("<backtab>" . avandu-previous-feed)
                 ("l" . recenter-top-bottom)
                 ("v" . scroll-up-command))
         :config (setq avandu-tt-rss-api-url my-private-personal-tt-rss-api-url
                       avandu-user my-private-personal-tt-rss-username
                       avandu-password my-private-personal-tt-rss-password))
     #+END_SRC

**** Elfeed
     #+BEGIN_SRC emacs-lisp
       (use-package elfeed
         :defer t
         :config
         ;; (elfeed-protocol-enable)
         (setq elfeed-feeds my-private-feeds
               elfeed-search-title-max-width 120

               elfeed-use-curl nil
               elfeed-protocol-ttrss-maxsize 200 ;; bigger than 200 is invalid

               elfeed-feeds
               'my-private-feeds))

       (use-package elfeed-org
         :defer t
         :after (elfeed org)
         :config
         (elfeed-org)
         (setq rmh-elfeed-org-auto-ignore-invalid-feeds t
               rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org")))
     #+END_SRC

*** Stories
    #+BEGIN_SRC emacs-lisp
      (use-package helm-lobsters
        :commands helm-lobsters)
    #+END_SRC

* Epilogue
  Last configuration steps :
  #+BEGIN_SRC emacs-lisp
    (add-hook 'emacs-startup-hook
              (lambda ()
                (create-project-hydra)
                (display-battery-mode)
                (when (string-equal "darwin" system-type)
                  (load-file
                   (expand-file-name "elisp/macos-environment.el" base-emacs-directory)))
                (when (or (string-equal "ms-dos" system-type)
                          (string-equal "windows-nt" system-type)
                          (string-equal "cygwin" system-type))
                  (load-file
                   (expand-file-name "elisp/windows-environment.el" base-emacs-directory)))
                (cond
                 ((daemonp)
                  (progn
                    (when (fboundp 'beacon-mode)           (beacon-mode -1))
                    (when (fboundp 'centaur-tabs-mode)     (centaur-tabs-mode -1))
                    (when (fboundp 'poke-line-global-mode) (poke-line-global-mode -1))))
                 (t
                  (progn
                    (when (fboundp 'beacon-mode)           (beacon-mode))
                    (when (fboundp 'centaur-tabs-mode)     (centaur-tabs-mode 1))
                    (when (fboundp 'poke-line-global-mode) (poke-line-global-mode))
                    (mouse-wheel-mode t))))))
  #+END_SRC
* Useful links
** one entry point to find them all
   - https://planet.emacslife.com/
** blogs
   - http://sachachua.com/blog/
** vlogs
   - http://emacsrocks.com/
   - https://mickael.kerjean.me/2017/03/18/emacs-tutorial-series-episode-0/
   - https://cestlaz.github.io/stories/emacs/
** configs
   - https://github.com/purcell/emacs.d
   - https://github.com/dakra/dmacs/blob/master/init.org
   - https://github.com/angrybacon/dotemacs
   - https://github.com/jwiegley/dot-emacs
** other
   - https://github.com/sebastiencs
