#+TITLE: Emacs configuration file
#+AUTHOR: Arthur Léothaud
#+EMAIL: arthur@leothaud.eu

#+STARTUP: showall

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+LANGUAGE: en

#+LINK_HOME: http://leothaud.eu
#+HTML_HEAD: <link rel=stylesheet type=text/css href=org.css />

* Startup
  Display emacs startup time, with the number of garbage collections during the process.
  #+BEGIN_SRC emacs-lisp
    ;; Use a hook so the message doesn't get clobbered by other messages.
    (add-hook 'emacs-startup-hook
              (lambda ()
                (message "Emacs ready in %s with %d garbage collections."
                         (format "%.2f seconds"
                                 (float-time
                                  (time-subtract after-init-time before-init-time)))
                         gcs-done)))
  #+END_SRC

  Start by “disabling” garbage collection while starting up:
  #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold most-positive-fixnum)
    ;; restore after startup
    (add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 20000000)))
  #+END_SRC

* Package Management
  I use [[https://github.com/jwiegley/use-package][use-package]] and [[https://melpa.org/][melpa]] to manage my packages and modules.
  #+BEGIN_SRC emacs-lisp
    ;; package-style dependencies
    (eval-when-compile
      (require 'package)
      (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
      (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
      (unless (package-installed-p 'use-package)
        (package-refresh-contents)
        (package-install 'use-package))
      (require 'use-package)
      (setq use-package-always-ensure t
            use-package-verbose t))

    (use-package delight)

    (use-package use-package-chords
      :config (key-chord-mode 1)
      (setq key-chord-one-key-delay 0.15)
      (setq key-chord-two-keys-delay 0.05))
  #+END_SRC

  This is the list of my (user-selected) packages:
  #+BEGIN_SRC emacs-lisp
    (setq package-selected-packages
          '(2048-game
            ace-jump-helm-line
            ace-window
            aggressive-indent
            all-the-icons
            anzu
            auctex-latexmk
            auto-yasnippet
            avandu
            beacon
            beginend
            browse-kill-ring
            butler
            calfw
            calfw-cal
            calfw-gcal
            calfw-ical
            calfw-org
            cargo
            change-inner
            color-identifiers-mode
            color-theme-modern
            command-log-mode
            company-box
            company-lsp
            company-prescient
            crontab-mode
            crux
            csv-mode
            dap-java
            dap-mode
            dap-ui-mode
            default-text-scale
            define-word
            delight
            describe-number
            dired-collapse
            dired-narrow
            dired-subtree
            docker
            dockerfile-mode
            dokuwiki
            dokuwiki-mode
            dot-mode
            dumb-jump
            edit-server
            editorconfig
            elfeed-org
            elisp-slime-nav
            elpy
            ensime
            expand-region
            fancy-battery
            fancy-narrow
            fish-mode
            flycheck-rust
            forge
            format-all
            git-gutter
            git-messenger
            git-timemachine
            gitconfig-mode
            gitignore-mode
            god-mode
            goto-last-change
            gradle-mode
            grip-mode
            groovy-mode
            guess-language
            helm-ag
            helm-cider
            helm-dash
            helm-descbinds
            helm-git-grep
            helm-gitlab
            helm-lines
            helm-lobsters
            helm-lsp
            helm-projectile
            helm-swoop
            helm-tramp
            helpful
            hide-mode-line
            highlight-indent-guides
            htmlize
            idle-highlight-mode
            imenu-anywhere
            impatient-mode
            isearch-dabbrev
            iy-go-to-char
            jedi
            jenkins
            js2-refactor
            json-reformat
            ledger-mode
            linum-relative
            litable
            load-dir
            lorem-ipsum
            lsp-helm
            lsp-java
            lsp-java-treemacs
            lsp-ui
            magit-org-todos
            magit-todos
            meghanada
            miniedit
            minimap
            move-text
            no-littering
            nov
            ob-restclient
            ob-shell
            org-bullets
            origami
            page-break-lines
            paradox
            persistent-scratch
            powerthesaurus
            pretty-hydra
            prism
            prog-fill
            racer
            rainbow-blocks
            rainbow-delimiters
            rainbow-mode
            region-bindings-mode
            sass-mode
            sbt-mode
            scala-mode
            shell-pop
            shrink-whitespace
            shx
            slime-volleyball
            smart-comment
            smart-mode-line
            smartparens
            smartscan
            sml-modeline
            speed-type
            sqlformat
            super-save
            swagger-to-org
            syslog-mode
            temporary-persistent
            tide
            transmission
            travis
            treemacs
            try
            undo-tree
            use-package-chords
            vimish-fold
            visual-regexp-steroids
            volatile-highlights
            web-mode
            webpaste
            wgrep
            which-key
            winnow
            yaml-mode
            yasnippet-snippets
            zop-to-char
            ztree))
  #+END_SRC

  Let’s use [[https://github.com/Malabarba/paradox][paradox]] to manage packages in a fancier way:
  #+BEGIN_SRC emacs-lisp
    (use-package paradox :disabled t
      :config (setq paradox-github-token t))
  #+END_SRC

  Try packages without installing them:
  #+BEGIN_SRC emacs-lisp
   (use-package try :defer t)
  #+END_SRC

* Emacs directory
  Let’s keep =~/.emacs.d= tidy:
  #+BEGIN_SRC emacs-lisp
   (use-package no-littering
     :config
     (require 'recentf)
     (setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
     (add-to-list 'recentf-exclude no-littering-var-directory)
     (add-to-list 'recentf-exclude no-littering-etc-directory))
  #+END_SRC

  Private information is stored in variables in =~/.emacs.d/private.el=
  #+BEGIN_SRC emacs-lisp
    (let ((private-file (expand-file-name "private.el" user-emacs-directory)))
      (when (file-exists-p private-file)
        (load-file private-file)))
  #+END_SRC

  Let’s load all files from the “extra” directory (will happen after init is finished).
  #+BEGIN_SRC emacs-lisp
    (use-package load-dir
      :config (setq load-dirs (expand-file-name "extra/" user-emacs-directory)))
  #+END_SRC

  Custom file should be loaded early.
  #+BEGIN_SRC emacs-lisp
    (setq-default custom-file (expand-file-name "custom.el" user-emacs-directory))
    (when (file-exists-p custom-file)
      (load custom-file))
  #+END_SRC

* Custom functions
  My custom (often stolen) lisp code is stored in =elisp/my-functions.el=.
  #+BEGIN_SRC emacs-lisp
    (use-package my-functions ;; custom functions
      :ensure nil
      :commands (ale/insert-ticket-prefix
                 ale/jirify
                 ale/find-init-file
                 ale/open-project
                 ale/apply-local-theme-modern)
      :load-path "elisp/"
      :bind
      ("M-é" . previous-user-buffer) ;; call previous buffer
      ("M-è" . next-user-buffer) ;; call next buffer
      ("<f5>" . ale/revert-buffer-no-confirm) ;; re-read file from disk
      ("C-<f5>" . ale/copy-and-show-current-file-path) ;; copy current file path
      ("M-<f5>" . show-file-name) ;; show the file name in minibuffer
      ("C-x |" . ale/toggle-window-split)
      ("C-|" . ale/toggle-window-split))
  #+END_SRC

* Help
  [[https://github.com/justbur/emacs-which-key][which-key]] displays all available bindings for the prefix that has just been typed.
  #+BEGIN_SRC emacs-lisp
    (use-package which-key ;; which-key (replacement for guide-key)
      :config
      (which-key-mode)
      (setq which-key-idle-delay 0.3))
  #+END_SRC

  [[https://github.com/Wilfred/helpful][Helpful]] adds more contextual information to the built-in help.
  #+BEGIN_SRC emacs-lisp
    (use-package helpful
      :bind
      ;; Note that the built-in `describe-function' includes both functions
      ;; and macros. `helpful-function' is functions only, so we provide
      ;; `helpful-callable' as a drop-in replacement.
      ("C-h f" . helpful-callable)
      ("C-h v" . helpful-variable)
      ("C-h k" . helpful-key)
      ;; Lookup the current symbol at point. C-c C-d is a common keybinding
      ;; for this in lisp modes.
      ("C-c C-d" . helpful-at-point)

      ;; Look up *F*unctions (excludes macros).
      ;;
      ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
      ;; already links to the manual, if a function is referenced there.
      ("C-h F" . helpful-function)

      ;; Look up *C*ommands.
      ;;
      ;; By default, C-h C is bound to describe `describe-coding-system'. I
      ;; don't find this very useful, but it's frequently useful to only
      ;; look at interactive functions.
      ("C-h C" . helpful-command))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package describe-number :defer t)
  #+END_SRC

* Defaults
  Let’s redefine some basic behaviour:

  First, let’s remove menus, toolbar, scrollbar, fringes.
  #+BEGIN_SRC emacs-lisp
    (menu-bar-mode -1)
    (when (fboundp 'tool-bar-mode)
      (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1))
    (when (fboundp 'horizontal-scroll-bar-mode)
      (horizontal-scroll-bar-mode -1))
    (fringe-mode 0)
  #+END_SRC

  Although I mainly use helm, ido is nice in some cases.
  #+BEGIN_SRC emacs-lisp
    (ido-mode t)
    (setq ido-enable-flex-matching t)
  #+END_SRC

  Let’s use UTF-8 everywhere:
  #+BEGIN_SRC emacs-lisp
    (prefer-coding-system       'utf-8)
    (set-default-coding-systems 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (setq default-buffer-file-coding-system 'utf-8)

    (use-package iso-transl ;; some environments don’t handle dead keys
      :ensure nil)
  #+END_SRC

  Some commands are disabled by default, let’s enable them:
  #+BEGIN_SRC emacs-lisp
    (put 'downcase-region 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'narrow-to-region 'disabled nil)
    (put 'narrow-to-page 'disabled nil)
    (put 'set-goal-column 'disabled nil)
    (put 'scroll-left 'disabled nil)
  #+END_SRC

  Let’s add some auto-backup configuration:
  #+BEGIN_SRC emacs-lisp
    (require 'saveplace)
    (setq-default save-place t)
    (setq save-place-file (concat user-emacs-directory "places")
          vc-make-backup-files t ;; make backups of files, even when they're in version control
          backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                   "backups"))))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (autoload 'zap-up-to-char "misc"
      "Kill up to, but not including ARGth occurrence of CHAR." t)

    (show-paren-mode 1)
    (setq save-interprogram-paste-before-kill t
          apropos-do-all t
          mouse-yank-at-point t
          require-final-newline t
          load-prefer-newer t
          ediff-window-setup-function 'ediff-setup-windows-plain)
    ;; Answer questions with y/n
    (defalias 'yes-or-no-p 'y-or-n-p)

    ;; Transparently open compressed files
    (auto-compression-mode t)

    ;; some more config
    (setq recentf-max-saved-items 100  ;; just 20 is too recent
          delete-by-moving-to-trash t ;; move files to trash when deleting
          savehist-additional-variables '(register-alist))
    (recentf-mode 1)
    (savehist-mode 1)

    ;; Lines should be 80 characters wide, not 70
    (setq-default fill-column 80)

    ;; fill or unfill paragraph (M-q as a toggle)
    (defun endless/fill-or-unfill ()
      "Like `fill-paragraph', but unfill if used twice."
      (interactive)
      (let ((fill-column
             (if (eq last-command 'endless/fill-or-unfill)
                 (progn (setq this-command nil)
                        (point-max))
               fill-column)))
        (call-interactively #'fill-paragraph)))
    (global-set-key [remap fill-paragraph]
                    #'endless/fill-or-unfill)

    (setq global-mark-ring-max 256
          mark-ring-max 256
          kill-ring-max 256)

    ;; use count-words instead of count-words-region as it works on buffer
    ;; if no region is selected
    (global-set-key (kbd "M-=") 'count-words)

    (global-font-lock-mode t) ;; enable syntax highlighting
    (blink-cursor-mode -1) ;; no blinking cursor

    (setq-default transient-mark-mode t ;; Show active region
                  truncate-lines t ;; Don't soft-break lines for me, please
                  truncate-string-ellipsis "…")

    (setq font-lock-maximum-decoration t ;; all possible colours
          inhibit-startup-screen t ;; No splash screen
          echo-keystrokes 0.1 ;; Show keystrokes in progress
          initial-scratch-message nil ;; No *scratch* message
          visible-bell nil ;; No flashing!
          line-number-mode t ;; Always display line number
          column-number-mode t ;; and column number
          shift-select-mode nil) ;; don't use shift to mark things
  #+END_SRC


  I don’t usually display line numbers, but I want the abilitity to do so, and also to display relative line numbering, which is handy to navigate using numeric arguments.
  #+BEGIN_SRC emacs-lisp
    ;; don’t display linum except while goto-line
    (global-set-key [remap goto-line] 'goto-line-with-feedback)

    (use-package linum-relative :defer t)
  #+END_SRC

  [[https://github.com/bbatsov/crux][Crux]] brings a lot of better default behaviour and functions.
  #+BEGIN_SRC emacs-lisp
    (use-package crux
      ;; replace some commands
      :bind
      ("C-M-<down>" . crux-duplicate-current-line-or-region)
      ("M-j" . crux-top-join-line)
      ("C-c i" . crux-cleanup-buffer-or-region)
      :config
      (global-set-key [remap move-beginning-of-line] #'crux-move-beginning-of-line)
      (global-set-key [remap kill-whole-line] #'crux-kill-whole-line)
      (crux-reopen-as-root-mode)
      ;; advices to make region-aware commands act on whole line if no region
      (crux-with-region-or-line comment-or-uncomment-region)
      ;; advices to make region-aware commands act on whole buffer if no region
      (crux-with-region-or-buffer indent-region)
      (crux-with-region-or-buffer untabify)
      (crux-with-region-or-buffer tabify))
  #+END_SRC

* Keybindings
  I use [[https://github.com/abo-abo/hydra][hydra]] in order to map ranges of key bindings:
  #+BEGIN_SRC emacs-lisp
    (use-package hydra :defer t)
    (use-package pretty-hydra :defer t)
  #+END_SRC

  Killing emacs; default binding is too easy to hit by accident.
  #+BEGIN_SRC emacs-lisp
    (global-unset-key (kbd "C-x C-c"))
    (global-set-key (kbd "C-x r q") 'kill-emacs) ;; r·eally q·uit
  #+END_SRC

  =M-«= and =M-»= are easier than =M-<= and =M->= with a BÉPO™ keyboard:
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-«") 'beginning-of-buffer)
    (global-set-key (kbd "M-»") 'end-of-buffer)
  #+END_SRC

  I never use the minimise command, use the binding for =repeat= instead.
  #+BEGIN_SRC emacs-lisp
    ;; repeat
    (global-set-key (kbd "C-z") 'repeat)
    (global-set-key (kbd "C-x C-z") 'repeat-complex-command)
  #+END_SRC

  Vim’s “dot” is a cool macro-like feature. I want that.
  #+BEGIN_SRC emacs-lisp
    (use-package dot-mode
      :chords (".." . dot-mode-execute)
      :config
      ;; default bindings I already use
      (unbind-key "C-." dot-mode-map)
      (unbind-key "C-c ." dot-mode-map)
      (global-dot-mode))
  #+END_SRC

  More custom bindings :
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-/") 'hippie-expand)
    (global-set-key (kbd "M-z") 'zap-up-to-char)
  #+END_SRC

* Modal editing
  I use [[https://github.com/chrisdone/god-mode][god-mode]] to implement a pseudo-modal behaviour. The cursor becomes red when in god-mode to make it more visible.
  #+BEGIN_SRC emacs-lisp
    (use-package god-mode
      :init (setq god-local-mode nil)
      :bind
      (("C-c g" . toggle-god-mode)
       :map god-local-mode-map
       ("i" . toggle-god-mode)
       ("." . repeat))
      :chords ("ii" . toggle-god-mode)
      :config
      (defun toggle-god-mode ()
        (interactive)
        (progn
          (god-mode-all)
          (my-update-cursor)))
      (setq god-mode-colors nil)
      (defun my-update-cursor ()
        "change cursor colour if god-mode is activated/deactivated effectively."
        (cond
         ((and god-local-mode (not god-mode-colors))
          (progn
            (set-cursor-color "red")
            (setq god-mode-colors t)))
         ((not god-local-mode)
          (progn
            (set-cursor-color "yellow")
            (setq god-mode-colors nil)))))

      (defadvice select-window (after update-cursor-color activate)
        (my-update-cursor))
      (add-to-list 'god-exempt-major-modes 'helm-major-mode)
      (add-to-list 'god-exempt-major-modes 'browse-kill-ring-mode)
      (add-to-list 'god-exempt-major-modes 'ibuffer-mode))
  #+END_SRC

* Appearance

  Always start in full screen.
  #+BEGIN_SRC emacs-lisp
    (if (eq window-system 'ns)
        (toggle-frame-maximized)
      (toggle-frame-fullscreen))
  #+END_SRC

** Theme
   Apply a colour theme (uses the variable =my-private-theme= if defined)
   #+BEGIN_SRC emacs-lisp
     (use-package color-theme-modern
       :init (add-to-list 'custom-theme-load-path
                          (file-name-as-directory (expand-file-name "themes" user-emacs-directory)))
       :config (ale/apply-local-theme-modern))
   #+END_SRC

** Zoom
   I use [[https://github.com/purcell/default-text-scale][default-text-scale]] to zoom in and out the whole emacs frame.
   #+BEGIN_SRC emacs-lisp
     (use-package default-text-scale
       :bind
       ("C-+" . default-text-scale-increase)
       ("C-=" . default-text-scale-decrease))
   #+END_SRC

** Highlight feedback
   Let’s have a visual feedback when performing cut/copy/paste operations.
   #+BEGIN_SRC emacs-lisp
     (use-package volatile-highlights :defer t)

     (use-package idle-highlight-mode :defer t)
   #+END_SRC

   Highlight current line in list buffers:
   #+BEGIN_SRC emacs-lisp
     (use-package highlight-line
       :ensure nil
       :config
       (global-hl-line-mode -1) ;; don’t highlight current line
       (highlight-line-mode 1) ;; except in “list” modes
       :load-path "elisp/")

     (use-package fancy-narrow
       :disabled t
       :config (fancy-narrow-mode t))

     (use-package highlight-indent-guides
       :config (setq highlight-indent-guides-method 'character)
       :hook (prog-mode . highlight-indent-guides-mode))
   #+END_SRC

   Prettify those ugly ==
   #+BEGIN_SRC emacs-lisp
     (use-package page-break-lines
       :config (global-page-break-lines-mode))
   #+END_SRC

   Beacon gives a nice visual feedback when the cursor moves around.
   #+BEGIN_SRC emacs-lisp
     (use-package beacon
     :defer t)
   #+END_SRC

** Icons in terminal
   #+BEGIN_SRC emacs-lisp
     (use-package font-lock+
       :ensure nil
       :load-path "elisp/")

     (use-package icons-in-terminal
       :ensure nil
       :load-path "~/.local/share/icons-in-terminal/")
     ;; (insert (icons-in-terminal 'oct_flame)) ; C-h f icons-in-terminal[RET] for more info

     (use-package all-the-icons)
   #+END_SRC

** Colours
   Colour parentheses according to nesting level:
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :hook (prog-mode . rainbow-delimiters-mode))
   #+END_SRC

   In some specific modes, I like to have the syntax highlighting replaced by a colouring according to nesting level.
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-blocks)

     (use-package prism)
   #+END_SRC

   Or according to symbol names.
   #+BEGIN_SRC emacs-lisp
     (use-package color-identifiers-mode)
   #+END_SRC

   When coding, colour codes and names should be displayed in this colour.
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-mode
       :hook (prog-mode . rainbow-mode))
   #+END_SRC
   Note: If I ever need to work seriously with colours: [[https://github.com/emacsfodder/kurecolor][kurecolor]]

** Fringes
   This is a “zen” mode that I took from [[https://bzg.fr/en/emacs-strip-tease.html/][Bastien’s config]]:
   #+BEGIN_SRC emacs-lisp
     ;; A small minor mode to use a big fringe
     (defvar bzg-big-fringe-mode nil)
     (define-minor-mode bzg-big-fringe-mode
       "Minor mode to use big fringe in the current buffer."
       :init-value nil
       :global t
       :variable bzg-big-fringe-mode
       :group 'editing-basics
       (if (not bzg-big-fringe-mode)
           (progn
             (fringe-mode 0))
         (progn (delete-other-windows)
                (custom-set-faces '(fringe ((t (:background "black")))))
                (set-fringe-mode
                 (/ (- (frame-pixel-width)
                       (* 100 (frame-char-width)))
                    2)))))
   #+END_SRC

* Dired
  #+BEGIN_SRC emacs-lisp
    (use-package dired
      :ensure nil
      :bind ("C-x C-j". dired-jump)
      :config
      (unbind-key "M-b" dired-mode-map)
      (put 'dired-find-alternate-file 'disabled nil)
      (setq dired-dwim-target t
            ;; dired human readable size format
            dired-listing-switches "-AlhF"
            auto-revert-verbose nil
            ;; always delete and copy recursively
            dired-recursive-deletes 'always
            dired-recursive-copies 'always))

    (use-package dired-narrow
      :bind (:map dired-mode-map ("/" . dired-narrow)))

    (use-package find-dired
      :config (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld")))

    (use-package dired-collapse
      :hook (dired-mode . (lambda () (dired-collapse-mode t))))

    (use-package dired-subtree
      :bind (:map dired-mode-map
                  ("U" . dired-subtree-up)
                  ("e" . dired-subtree-narrow)
                  ("i" . dired-subtree-toggle)
                  ("«" . dired-subtree-beginning)
                  ("»" . dired-subtree-end)))
  #+END_SRC

* Navigation
  I use [[https://github.com/abo-abo/ace-window][ace-window]] to quickly switch windows…
  #+BEGIN_SRC emacs-lisp
    (use-package ace-window
      :bind ("M-o" . ace-window)
      ("<s-down>" . other-window))
  #+END_SRC

  … and avy to directly jump to a char.
  #+BEGIN_SRC emacs-lisp
    (use-package avy
      :bind
      ("M-à" . avy-goto-word-1) ;; quickly jump to word by pressing its first letter
      ("C-à" . avy-goto-char-timer) ;; quickly jump to any char in word
      :config
      (setq avy-keys '(97 117 105 101 98 233 112 111 116 115 114 110 109 118 100 108 106 99 113 103 104 102)))
  #+END_SRC

  Equivalent of ~f~ key in vim:
  #+BEGIN_SRC emacs-lisp
    (use-package iy-go-to-char
      :chords
      ("àà" . iy-go-up-to-char)
      ("éé" . iy-go-to-char)
      ("êê" . iy-go-to-char-backward)
      :bind ("M-m" . iy-go-to-char))
  #+END_SRC

  I use the nice ~beginend~ package to enhance ~beginning-of-buffer~ and ~end-of-buffer~ commands.
  #+BEGIN_SRC emacs-lisp
    (use-package beginend
      :config (beginend-global-mode))
  #+END_SRC

  More navigation commands:
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-S-p") 'up-arrow)
    (global-set-key (kbd "C-S-n") 'down-arrow)

    (use-package imenu-anywhere
      :bind ("C-c ." . helm-imenu-anywhere))

    (use-package dumb-jump
      :bind (:map prog-mode-map
                  ("C-." . dumb-jump-go)
                  ("C-," . dumb-jump-back)
                  ("C-;" . dumb-jump-quick-look)))

    (use-package minimap :defer t)

    ;; Allow scrolling with mouse wheel
    (when (display-graphic-p) (progn(mouse-wheel-mode t)
                                    (mouse-avoidance-mode 'none)))

    (use-package goto-last-change
      :bind
      ("C-x C-/" . goto-last-change)
      ("C-x /" . goto-last-change)
      :config (make-command-repeatable 'goto-last-change))
  #+END_SRC

* Whitespace
  I just heard of [[https://github.com/editorconfig/editorconfig-emacs][editorconfig]], which sounds like a sensible way of dealing with formatting issues accross multiple IDEs/Projects/developers
  #+BEGIN_SRC emacs-lisp
    (use-package editorconfig :defer t)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c w") 'delete-trailing-whitespace)

    (use-package aggressive-indent
      :hook (prog-mode . aggressive-indent-mode))

    ;;Indentation
    (setq-default tab-width 2
                  c-auto-newline t
                  c-basic-offset 2
                  c-block-comment-prefix ""
                  c-default-style "k&r"
                  indent-tabs-mode nil ;; <tab> inserts spaces, not tabs and spaces
                  sentence-end-double-space nil) ;; Sentences end with a single space

    ;; use tab to auto-comlete if indentation is right
    (setq tab-always-indent 'complete)

    (use-package shrink-whitespace
      :bind ("C-x C-o" . shrink-whitespace))
  #+END_SRC

* Folding
  I use [[https://github.com/gregsexton/origami.el][origami]]…
  #+BEGIN_SRC emacs-lisp
    (use-package origami
      :hook (prog-mode . origami-mode)
      :config (setq origami-fold-replacement "..."))
  #+END_SRC

  … and [[https://github.com/mrkkrp/vimish-fold][vimish-fold]].
  #+BEGIN_SRC emacs-lisp
    (use-package vimish-fold
      :bind
      (:map vimish-fold-folded-keymap ("<tab>" . vimish-fold-unfold)
            :map vimish-fold-unfolded-keymap ("<tab>" . vimish-fold-refold))
      :config
      (vimish-fold-global-mode 1)
      (setq-default vimish-fold-dir (expand-file-name ".vimish-fold/" user-emacs-directory)
                    vimish-fold-header-width 79))
  #+END_SRC

  I also use =selective-display= as a more simple folding method.
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-%") 'ale/toggle-selective-display)
  #+END_SRC

  I use a hydra to have all those commands in one place.
  #+BEGIN_SRC emacs-lisp
    (pretty-hydra-define hydra-fold
      (:color pink :quit-key "q")
      ("built-in"
       (("s" ale/toggle-selective-display "selective display")
        ("n" narrow-to-defun "narrow"))
       "vimish fold"
       (("f" vimish-fold "fold")
        ("k" vimish-fold-delete "kill")
        ("K" vimish-fold-delete-all "kill all")
        ("p" vimish-fold-previous-fold "go previous")
        ("n" vimish-fold-next-fold "go next")
        ("<tab>" vimish-fold-toggle "toggle current")
        ("a" vimish-fold-toggle-all "toggle all"))
       "origami"
       (("x" origami-toggle-all-nodes "toggle all")
        ("y" origami-show-only-node "show only node")
        ("c" origami-recursively-toggle-node "cycle"))
       ))
    (global-set-key (kbd "C-c <tab>") 'hydra-fold/body)
  #+END_SRC
* Search & Navigation
** isearch
   Standard isearch by default:
   #+BEGIN_SRC emacs-lisp
    (use-package isearch-dabbrev
      :bind (:map isearch-mode-map
                  ("<tab>" . isearch-dabbrev-expand)
                  ("M-/" . isearch-dabbrev-expand)))

    (use-package smartscan
      :bind
      ("M-n". smartscan-symbol-go-forward) ;; find next occurence of word at point
      ("M-p". smartscan-symbol-go-backward) ;; find previous occurence of word at point
      ("M-'". smartscan-symbol-replace)) ;; replace all occurences of word at point
   #+END_SRC

** Regular expressions
   #+BEGIN_SRC emacs-lisp
     ;; regexp-builder
     (use-package re-builder
       :defer t
       :config (setq reb-re-syntax 'string)) ;; syntax used in the re-buidler

     (use-package visual-regexp-steroids
       :bind
       (("M-s r" . vr/replace)
        ("M-s q" . vr/query-replace)
        ("C-M-%" . vr/query-replace)
        ;; if you use multiple-cursors, this is for you:
        ("M-s m" . vr/mc-mark)
        ;; to use visual-regexp-steroids's isearch instead of the built-in regexp isearch, also include the following lines:
        ("C-r" . isearch-backward)
        ("C-s" . isearch-forward)
        ("C-M-r" . vr/isearch-backward)
        ("C-M-s" . vr/isearch-forward))
       :config (require 'visual-regexp)) ;; TODO check if really necessary
   #+END_SRC
   Note: there seems to be a [[http://cpansearch.perl.org/src/YEWENBIN/Emacs-PDE-0.2.16/lisp/re-builder-x.el][re-builder supporting perl syntax]].

* Completion & help
** Completion
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :hook (prog-mode . global-company-mode)
       :config
       (global-company-mode 1) ;; enable company in all buffers
       (setq company-tooltip-limit 30
             company-dabbrev-downcase nil
             company-show-numbers t))

     (use-package company-prescient
       :after company
       :config
       (company-prescient-mode)
       (prescient-persist-mode))

     (use-package company-box
       :after company)

     (use-package browse-kill-ring
       :config
       (browse-kill-ring-default-keybindings)
       (setq browse-kill-ring-quit-action 'save-and-restore))

     ;; case-insensitive policy
     (setq completion-ignore-case t
           pcomplete-ignore-case t
           read-file-name-completion-ignore-case t
           read-buffer-completion-ignore-case t)
   #+END_SRC

** Undo
   [[http://www.dr-qubit.org/undo-tree.html][undo-tree]] is a powerful undo/redo mode that treats undo history as a tree.
   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :pretty-hydra
       ((:color teal :quit-key "q")
        ("Navigate"
         (("p" undo-tree-undo "↶ undo" :color red)
          ("n" undo-tree-redo "↷ redo" :color red))
         "Manage"
         (("v" undo-tree-visualize "visualize")
          ("s" undo-tree-save-history "save")
          ("l" undo-tree-load-history "load"))))
       :bind (("C-M-/" . undo-tree-redo)
              ("C-c u" . undo-tree-hydra/body))
       :config
       (global-undo-tree-mode)
       (setq undo-tree-visualizer-timestamps t
             undo-tree-enable-undo-in-region nil
             undo-tree-visualizer-diff t
             undo-tree-auto-save-history t
             undo-outer-limit 3000000))
   #+END_SRC

** Ivy, counsel, swiper
   Once in a while, I try to use {ivy|counsel|swiper} (only to go back to helm ^^).
   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :disabled
       :config
       (ivy-mode nil)
       ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
       (setq ivy-use-virtual-buffers t)
       ;; number of result lines to display
       (setq ivy-height 30)
       ;; does not count candidates
       (setq ivy-count-format "%d/%d ")
       ;; no regexp by default
       (setq ivy-initial-inputs-alist nil)
       ;; configure regexp engine.
       (setq ivy-re-builders-alist
             ;; allow input not in order
             '((t . ivy--regex-ignore-order))))

     (use-package counsel
       :disabled
       :bind ("M-s s" . counsel-grep-or-swiper))
   #+END_SRC

** Helm
   Main =helm= configuration, with a big hydra as an entry point for almost all helm commands I use.
   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :chords
       ("bf" . helm-for-files) ;; snappy helm instance
       ("éè" . my-do-ag-project-root-or-dir) ;; grep in current project or dir
       ("«»" . hydra-helm-config/body) ;; all (useful) helm commands in one hydra
       :bind
       (("M-x" . helm-M-x) ;; superior to M-x
        ("C-x M-x" . execute-extended-command)
        ("C-c h" . hydra-helm-config/body)
        ("C-h a" . helm-apropos)
        :map helm-map
        ("M-«" . helm-beginning-of-buffer)
        ("M-»" . helm-end-of-buffer)
        :map minibuffer-local-map
        ("C-c C-l" . helm-minibuffer-history))
       :config
       (require 'helm-config)
       (helm-mode 0) ;; only on demand
       (helm-autoresize-mode t)
       (semantic-mode 1) ;; useful for imenu-like navigation
       (setq helm-M-x-fuzzy-match t
             helm-locate-command "locate %s -e -A --regex %s -d ~/mlocate.db"
             helm-adaptive-mode t
             helm-ag-base-command "ag --nocolor --nogroup --smart-case"
             helm-ag-insert-at-point 'symbol
             helm-buffer-max-length nil
             helm-buffers-fuzzy-matching t
             helm-candidate-number-limit 300
             helm-echo-input-in-header-line nil
             helm-external-programs-associations '(("mp3" . "audacious"))
             helm-ff-file-name-history-use-recentf t
             helm-ff-skip-boring-files t
             helm-net-prefer-curl t
             helm-recentf-fuzzy-match t
             helm-split-window-default-side 'right
             helm-for-files-preferred-list '(helm-source-buffers-list
                                             helm-source-bookmarks
                                             helm-source-recentf
                                             helm-source-files-in-current-dir
                                             helm-source-file-cache
                                             ;; helm-source-file-name-history
                                             helm-source-locate
                                             helm-source-find-files)
             helm-boring-file-regexp-list '("\\.o$"
                                            "~$"
                                            "\\.bin$"
                                            "\\.lbin$"
                                            "\\.so$"
                                            "\\.a$"
                                            "\\.ln$"
                                            "\\.blg$"
                                            "\\.bbl$"
                                            "\\.elc$"
                                            "\\.lof$"
                                            "\\.glo$"
                                            "\\.idx$"
                                            "\\.lot$"
                                            "\\.svn\\(/\\|$\\)"
                                            "\\.hg\\(/\\|$\\)"
                                            "\\.git\\(/\\|$\\)"
                                            "\\.bzr\\(/\\|$\\)"
                                            "CVS\\(/\\|$\\)"
                                            "_darcs\\(/\\|$\\)"
                                            "_MTN\\(/\\|$\\)"
                                            "\\.fmt$"
                                            "\\.tfm$"
                                            "\\.class$"
                                            "\\.fas$"
                                            "\\.lib$"
                                            "\\.mem$"
                                            "\\.x86f$"
                                            "\\.sparcf$"
                                            "\\.dfsl$"
                                            "\\.pfsl$"
                                            "\\.d64fsl$"
                                            "\\.p64fsl$"
                                            "\\.lx64fsl$"
                                            "\\.lx32fsl$"
                                            "\\.dx64fsl$"
                                            "\\.dx32fsl$"
                                            "\\.fx64fsl$"
                                            "\\.fx32fsl$"
                                            "\\.sx64fsl$"
                                            "\\.sx32fsl$"
                                            "\\.wx64fsl$"
                                            "\\.wx32fsl$"
                                            "\\.fasl$"
                                            "\\.ufsl$"
                                            "\\.fsl$"
                                            "\\.dxl$"
                                            "\\.lo$"
                                            "\\.la$"
                                            "\\.gmo$"
                                            "\\.mo$"
                                            "\\.toc$"
                                            "\\.aux$"
                                            "\\.cp$"
                                            "\\.fn$"
                                            "\\.ky$"
                                            "\\.pg$"
                                            "\\.tp$"
                                            "\\.vr$"
                                            "\\.cps$"
                                            "\\.fns$"
                                            "\\.kys$"
                                            "\\.pgs$"
                                            "\\.tps$"
                                            "\\.vrs$"
                                            "\\.pyc$"
                                            "\\.pyo$"
                                            "\\.egradle/sdk\\(/\\|$\\)"
                                            "\\.cache/mozilla\\(/\\|$\\)"
                                            "\\.local/share/Trash/files\\(/\\|$\\)"
                                            "\\.cache/\\(chromium\\|google\\-chrome\\)/Default/Cache\\(/\\|$\\)"))

       (pretty-hydra-define hydra-helm-config
         (:color teal :quit-key "q")
         ("Find"
          (("l"     helm-locate "locate")
           ("/"     helm-find "find")
           ("F"     helm-find-files "files")
           ("f"     helm-for-files "all files") ;; like helm-multi-files but always run locate
           ("m"     helm-mini "mini")
           ("p"     helm-projectile "projectile")
           ("t"     helm-tramp "tramp"))
          "Search"
          (("R"     helm-regexp "regexp" :column "Search")
           ("o"     helm-occur "occur")
           ("a"     helm-do-grep-ag "ag grep")
           ("G"     helm-git-grep "git grep"))
          "Navigate"
          (("e"     helm-etags-select "etags")
           ("i"     helm-semantic-or-imenu "imenu")
           ("I"     helm-imenu-in-all-buffers "imenu all")
           ("."     helm-imenu-anywhere "imenu any")
           ("b"     helm-filtered-bookmarks "bookmark")
           ("'"     helm-register "register")
           ("k"     helm-show-kill-ring "kill-ring")
           ("<SPC>" helm-all-mark-rings "all mark rings"))
          "Completion"
          (("<tab>" helm-lisp-completion-at-point "lisp")
           ("$"     helm-lines "lines")
           ("g"     helm-google-suggest "google")
           ("s"     helm-surfraw "surfraw")
           ("y"     yas-insert-snippet "yasnippet")
           ("w"     helm-wikipedia-suggest "wikipedia"))
          "Doc & Help"
          (("h b"   helm-descbinds "bindings")
           ("h e"   helm-eval-expression-with-eldoc "eldoc")
           ("h i"   helm-info-at-point "info")
           ("h r"   helm-info-emacs "emacs")
           ("h g"   helm-info-gnus "gnus")
           ("h h"   helm-documentation "doc")
           ("h a"   helm-apropos "a propos")
           ("h m"   helm-man-woman "woman")
           ("-"     helm-dash-at-point "dash"))
          "Other"
          (("r"     helm-resume "resume" :column "Helm")
           ("T"     helm-top "top")
           ("P"     helm-list-emacs-process "process")
           ("c"     helm-colors "colours")
           ("8"     helm-ucs "ucs")
           (","     helm-calcul-expression "calcul")
           ("j"     helm-list-elisp-packages "packages")
           ("X"     helm-select-xfont "xfont")
           ("x"     helm-run-external-command "run external"))))

       (defun my-do-ag-project-root-or-dir ()
         "call helm-do-ag-project-root if in project, helm-do-ag otherwise"
         (interactive)
         (require 'helm-ag)
         (let ((rootdir (helm-ag--project-root)))
           (unless rootdir (helm-do-ag default-directory))
           (helm-do-ag rootdir))))
   #+END_SRC

   =helm-descbinds= lets me browse all user-defined keybindings.
   #+BEGIN_SRC emacs-lisp
      (use-package helm-descbinds
        :bind ("C-h b" . helm-descbinds))
   #+END_SRC

   =helm-dash= allows access to the full documentation of a language.
   #+BEGIN_SRC emacs-lisp
     (use-package helm-dash
       :after helm
       :config
       (setq helm-dash-browser-func 'eww)
       (add-hook 'clojure-mode-hook #'(lambda () (setq-local helm-dash-docsets '("Clojure"))))
       (add-hook 'java-mode-hook #'(lambda () (setq-local helm-dash-docsets '("Java"))))
       (add-hook 'js-mode-hook #'(lambda () (setq-local helm-dash-docsets '("Javascript"))))
       (add-hook 'rust-mode-hook #'(lambda () (setq-local helm-dash-docsets '("Rust")))))
   #+END_SRC

   Let’s make =ace-jump-mode= also available during a helm session.
   #+BEGIN_SRC emacs-lisp
      (use-package ace-jump-helm-line
        :bind (:map helm-map ("M-à" . ace-jump-helm-line)))
   #+END_SRC

   Let’s add some grepping facilities.
   #+BEGIN_SRC emacs-lisp
     (use-package wgrep
       :bind (:map grep-mode-map
                   ("C-x C-q" . wgrep-change-to-wgrep-mode)
                   ("C-c C-c" . wgrep-finish-edit)))
     (use-package helm-ag
       :bind (:map helm-ag-mode-map
                   ("p" . previous-line)
                   ("n" . next-line)
                   ("C-x C-q" . wgrep-change-to-wgrep-mode)
                   ("C-c C-c" . wgrep-finish-edit)))
   #+END_SRC

   =Helm-swoop= can be called during =isearch= to make searching easier with big files or big number of occurences.
   #+BEGIN_SRC emacs-lisp
     (use-package helm-swoop
       :bind
       ("C-S-s" . helm-swoop)
       (:map isearch-mode-map
             ;; When doing isearch, hand the word over to helm-swoop
             ("M-i" . helm-swoop-from-isearch))
       (:map helm-swoop-map
             ;; From helm-swoop to helm-multi-swoop-all
             ("M-i" . helm-multi-swoop-all-from-helm-swoop)
             ;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
             ("M-m" . helm-multi-swoop-current-mode-from-helm-swoop)
             ;; Move up and down like isearch
             ("C-r" . helm-previous-line)
             ("C-s" . helm-next-line)
             ("C-r" . helm-previous-line)
             ("C-s" . helm-next-line))
       :config
       ;; Save buffer when helm-multi-swoop-edit complete
       (setq helm-multi-swoop-edit-save t

             ;; If this value is t, split window inside the current window
             helm-swoop-split-with-multiple-windows nil

             ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
             helm-swoop-split-direction 'split-window-horizontally

             ;; If nil, you can slightly boost invoke speed in exchange for text color
             helm-swoop-speed-or-color t

             ;; ;; Go to the opposite side of line from the end or beginning of line
             helm-swoop-move-to-line-cycle nil

             ;; Optional face for line numbers
             ;; Face name is `helm-swoop-line-number-face`
             helm-swoop-use-line-number-face t

             ;; If you prefer fuzzy matching
             helm-swoop-use-fuzzy-match nil))
   #+END_SRC

   Let’s enable a git-aware grep search
   #+BEGIN_SRC emacs-lisp
     (use-package helm-git-grep
       :after helm)
   #+END_SRC

   Let’s add a helm module to auto-complete full lines.
   #+BEGIN_SRC emacs-lisp
     (use-package helm-lines
       :commands (helm-lines))
   #+END_SRC

   Finally, let’s use helm for connecting to remote hosts (via TRAMP).
   #+BEGIN_SRC emacs-lisp
     ;; (use-package helm-tramp
     ;;   :config
     ;;   (setq tramp-default-method "ssh"))
   #+END_SRC

** Snippets
   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :commands yas-new-snippet yas-insert-snippet
       :chords ("yq" . hydra-yasnippet/body)
       :bind
       ("<backtab>" . yas-ido-expand)
       ("C-h y" . yas-describe-tables)
       ("C-c y" . hydra-yasnippet/body)
       :config
       (use-package auto-yasnippet
         :config
         (setq aya-persist-snippets-dir (concat user-emacs-directory "etc/yasnippet/snippets")))
       (setq yas-snippet-dirs
             `(,(concat user-emacs-directory "etc/yasnippet/snippets")
               ,(car (file-expand-wildcards (concat user-emacs-directory "elpa/yasnippet-snippets-20*/snippets")))))
       (add-to-list 'yas-prompt-functions 'yas-helm-prompt)
       ;; Completing point by some yasnippet key

       (defun yas-ido-expand ()
         "Lets you select (and expand) a yasnippet key"
         (interactive)
         (let ((original-point (point)))
           (while (and
                   (not (= (point) (point-min) ))
                   (not
                    (string-match "[[:space:]\n]" (char-to-string (char-before)))))
             (backward-word 1))
           (let* ((init-word (point))
                  (word (buffer-substring init-word original-point))
                  (list (yas-active-keys)))
             (goto-char original-point)
             (let ((key (remove-if-not
                         (lambda (s) (string-match (concat "^" word) s)) list)))
               (if (= (length key) 1)
                   (setq key (pop key))
                 (setq key (ido-completing-read "key: " list nil nil word)))
               (delete-char (- init-word original-point))
               (insert key)
               (yas-expand)))))

       (defun yas-helm-prompt (prompt choices &optional display-fn)
         "Use helm to select a snippet. Put this into `yas-prompt-functions.'"
         (interactive)
         (setq display-fn (or display-fn 'identity))
         (if (require 'helm-config)
             (let (tmpsource cands result rmap)
               (setq cands (mapcar (lambda (x) (funcall display-fn x)) choices))
               (setq rmap (mapcar (lambda (x) (cons (funcall display-fn x) x)) choices))
               (setq tmpsource
                     (list
                      (cons 'name prompt)
                      (cons 'candidates cands)
                      '(action . (("Expand" . (lambda (selection) selection))))
                      ))
               (setq result (helm-other-buffer '(tmpsource) "*helm-select-yasnippet"))
               (if (null result)
                   (signal 'quit "user quit!")
                 (cdr (assoc result rmap))))
           nil))

       (pretty-hydra-define hydra-yasnippet
         (:color teal :quit-key "q")
         ("Snippet"
          (("t" yas-describe-tables "tables")
           ("r" yas-reload-all "reload"))
          "Insert"
          (("e" yas-ido-expand "ido expand")
           ("i" yas-insert-snippet "insert"))
          "Edit"
          (("n" yas-new-snippet "new")
           ("v" yas-visit-snippet-file "visit file"))
          "Auto-yasnippet"
          (("c" aya-create "create (with $, ~ or `')")
           ("a" aya-expand "apply")
           ("p" aya-persist-snippet "persist"))))

       (use-package yasnippet-snippets)
       (yas-reload-all)
       (yas-global-mode 1))
   #+END_SRC

*** More grepping
    #+BEGIN_SRC emacs-lisp
      (use-package winnow)
    #+END_SRC

* Text manipulation
** Region
   #+BEGIN_SRC emacs-lisp
    (use-package expand-region
      :bind ("C-c e" . er/expand-region))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
    (use-package region-bindings-mode
      :config (region-bindings-mode-enable))
   #+END_SRC

** Point movements
   #+BEGIN_SRC emacs-lisp
     (use-package move-text
       :config (move-text-default-bindings)) ;; M-up / M-down to move line or region

     (use-package zop-to-char
       :bind ("C-M-z" . zop-up-to-char))

     (use-package multiple-cursors
       :demand mc-mark-more
       :bind (:map region-bindings-mode-map
                   ("a" . mc/mark-all-like-this) ;; new cursor on each occurence of current region
                   ("d" . mc/mark-all-symbols-like-this-in-defun)
                   ("D" . mc/mark-all-dwim)
                   ("p" . mc/mark-previous-like-this) ;; new cursor on previous occurence of current region
                   ("n" . mc/mark-next-like-this) ;; new cursor on next occurence of current region
                   ("P" . mc/unmark-previous-like-this)
                   ("N" . mc/unmark-next-like-this)
                   ("é" . mc/edit-lines) ;; new cursor on each line of region
                   ("(" . mc/cycle-backward)
                   (")" . mc/cycle-forward)
                   ("m" . mc/mark-more-like-this-extended)
                   ("h" . mc-hide-unmatched-lines-mode)
                   ("v" . mc/vertical-align)
                   ("|" . mc/vertical-align-with-space)
                   ("r" . mc/reverse-regions)
                   ("s" . mc/sort-regions)
                   ("#" . mc/insert-numbers) ; use num prefix to set the starting number
                   ("^" . mc/edit-beginnings-of-lines)
                   ("$" . mc/edit-ends-of-lines)
                   ("<down>" . move-text-down)
                   ("<up>" . move-text-up))
       :config (setq mc/list-file (concat user-emacs-directory "var/mc-list.el")))

     (use-package smart-comment
       :bind ("M-;" . smart-comment))

     ;; Remove text in active region if inserting text
     (pending-delete-mode t)

     ;; Allow pasting selection outside of Emacs
     (setq-default select-enable-clipboard t
                   x-select-enable-clipboard t)

     (global-set-key (kbd "M-y") 'yank-pop)
     ;; easier access to transposition commands
     (global-set-key (kbd "C-x M-h") 'transpose-paragraphs)
     (global-set-key (kbd "C-§") 'transpose-paragraphs)
     (global-set-key (kbd "C-x M-s") 'transpose-sentences)
     (global-set-key (kbd "C-x M-t") 'transpose-sexps)

     (use-package repeatable ;; TODO add repeatable commands (or replace package with easy-repeat
       :ensure nil
       :load-path "elisp/")

     (global-set-key (kbd "C-x _") 'ale/toggle-camel-snake-kebab-case)

     (use-package change-inner
       :bind ("M-s i" . change-inner)
       ("M-s o" . change-outer))
     ;;     (global-set-key (kbd "M-i") 'change-inner)
     ;;     (global-set-key (kbd "M-o") 'change-outer)

     (use-package emacs-surround
       :ensure nil
       :bind ("M-s s" . emacs-surround)
       :load-path "elisp/")
   #+END_SRC

** Diffing
   #+BEGIN_SRC emacs-lisp
     (use-package ztree
       :bind (:map ztree-mode-map
                   ("o" . ztree-jump-side)
                   ("l" . recenter-top-bottom)
                   ("n" . ztree-next-line)
                   ("p" . ztree-previous-line)))
   #+END_SRC

* Buffer & window manipulation
** Windows
   Better access to window manipulation commands:
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-\"") 'delete-other-windows)
     (global-set-key (kbd "C-«") 'split-window-below)
     (global-set-key (kbd "C-»") 'split-window-right)
     (global-set-key (kbd "C-*") 'delete-window)
   #+END_SRC

   Revert windows on ediff exit - needs winner mode.
   #+BEGIN_SRC emacs-lisp
     (use-package winner
       :bind
       ("<s-left>" . winner-undo)
       ("<s-right>" . winner-redo)
       :config (winner-mode))
   #+END_SRC

** Buffer Management
   Change how buffer names are made unique.
   #+BEGIN_SRC emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style 'post-forward
           uniquify-separator ":")
   #+END_SRC

   Auto-refresh all buffers.
   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode 1)
   #+END_SRC

   Some more buffer manipulation bindings.
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x M-b") 'ibuffer) ;; call ibuffer
     (global-set-key (kbd "C-x C-b") 'electric-buffer-list) ;; electric buffer by default
     (global-set-key (kbd "C-c o") 'bury-buffer) ;; put buffer at bottom of buffer list
     (global-set-key (kbd "C-c k") 'kill-this-buffer) ;; kill buffer without confirmation
     (key-chord-define-global (kbd "+-") 'kill-this-buffer) ;; kill buffer without confirmation
   #+END_SRC

*** Scratch
    #+BEGIN_SRC emacs-lisp
      (setq initial-major-mode 'text-mode)
      (global-set-key (kbd "C-x \"") 'crux-create-scratch-buffer)
      (global-set-key (kbd "M-\"") 'crux-create-scratch-buffer)

      (use-package temporary-persistent)

      (use-package persistent-scratch
        :config
        (persistent-scratch-setup-default)
        (defun persistent-scratch-numbered-scratch-buffer-p ()
          "Return non-nil iff the current buffer's name begins with *scratch*."
          (and (> (length (buffer-name)) 8)
               (string-equal "*scratch*"  (substring (buffer-name) 0 9))))
        (setq persistent-scratch-scratch-buffer-p-function 'persistent-scratch-numbered-scratch-buffer-p))
    #+END_SRC

*** Minibuffer
    #+BEGIN_SRC emacs-lisp
      ;; C-M-e to edit minibuffer in a full-size buffer
      (use-package miniedit
        :commands minibuffer-edit
        :init (miniedit-install))
    #+END_SRC

* Version control

  Always follow symbolic links for files under VC.
  #+BEGIN_SRC emacs-lisp
     (use-package vc
       :defer t
       :config (setq vc-follow-symlinks t))
  #+END_SRC

** Diff
*** vdiff
    #+BEGIN_SRC emacs-lisp
      (use-package vdiff
        :disabled
        :bind (:map vdiff-mode-map
                    ("C-c" . vdiff-mode-prefix-map))
        :init (define-key vdiff-mode-map (kbd "C-c") vdiff-mode-prefix-map)
        :config
        (setq
         ;; Whether to lock scrolling by default when starting vdiff
         vdiff-lock-scrolling t
         ;; external diff program/command to use
         vdiff-diff-program "diff"
         ;; Extra arguments to pass to diff. If this is set wrong, you may break vdiff.
         vdiff-diff-program-args ""
         ;; Commands that should be executed in other vdiff buffer to keep lines in
         ;; sync. There is no need to include commands that scroll the buffer here,
         ;; because those are handled differently.
         vdiff-mirrored-commands '(next-line
                                   previous-line
                                   beginning-of-buffer
                                   end-of-buffer)
         ;; Minimum number of lines to fold
         vdiff-fold-padding 2
         ;; Unchanged lines to leave unfolded around a fold
         vdiff-min-fold-size 4
         ;; Function that returns the string printed for a closed fold. The arguments
         ;; passed are the number of lines folded, the text on the first line, and the
         ;; width of the buffer.
         vdiff-fold-string-function 'vdiff-fold-string-default))
    #+END_SRC

*** ediff
    #+BEGIN_SRC emacs-lisp
      ;; A saner ediff
      (setq ediff-diff-options "-w"
            ediff-split-window-function 'split-window-horizontally
            ediff-window-setup-function 'ediff-setup-windows-plain)
    #+END_SRC

** Git tools
   #+BEGIN_SRC emacs-lisp
      (use-package git-timemachine :defer t)

      (use-package git-messenger
        :bind (:map git-messenger-map
                    ("d" . git-messenger:popup-diff)
                    ("s" . git-messenger:)
                    ("c" . git-messenger:copy-commit-id))
        :hook (git-messenger:popup-buffer-hook . magit-commit-mode)
        :config (setq git-messenger:show-detail t))

      (use-package gitignore-mode
        :mode ".gitignore$")

      (use-package gitconfig-mode
        :mode ".gitconfig$")

      (use-package git-gutter
        :hook (prog-mode)
        :bind
        ("M-N" . git-gutter:next-hunk)
        ("M-P" . git-gutter:previous-hunk)
        :config
        (global-git-gutter-mode +1)
        (setq git-gutter:ask-p nil
              git-gutter:hide-gutter t))
   #+END_SRC

** Magit
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :chords ("qg" . magit-status) ;; run git status for current buffer
       :bind
       ("C-x g" . hydra-git/body)
       (:map magit-file-mode-map ("C-x g" . hydra-git/body))
       :config (magit-define-popup-switch 'magit-log-popup ?w "date-order" "--date-order")
       (setq magit-branch-arguments nil
             magit-fetch-arguments  '("--prune")
             magit-log-arguments '("--graph" "--color" "--decorate" "--date-order" "-n100")
             magit-stash-arguments  '("--include-untracked"))

       (pretty-hydra-define hydra-git
         (:color blue :quit-key "q")
         ("Gutter"
          (("n" git-gutter:next-hunk "next hunk" :color pink)
           ("p" git-gutter:previous-hunk "prev hunk" :color pink)
           ("r" git-gutter:revert-hunk "revert hunk" :color pink)
           ("s" git-gutter:stage-hunk "stage hunk" :color pink)
           ("u" git-gutter-mode "gutter mode"))
          "Log"
          (("b" magit-blame "blame")
           ("l" magit-log-buffer-file "file history")
           ("t" git-timemachine "time machine"))
          "Other"
          (("." magit-status "status")
           ("g" git-messenger:popup-message "message")
           ("f" magit-file-popup "file popup")))))

     (use-package forge
       :after magit)

     (use-package magit-todos
       :after magit
       :config (setq magit-todos-max-items 30))

     (use-package magit-org-todos
       :after magit
       :config
       (magit-org-todos-autoinsert))
   #+END_SRC

* Project management
  I use [[https://github.com/bbatsov/helm-projectile][helm-projectile]] to manage my projects (mostly git projects).
  #+BEGIN_SRC emacs-lisp
    (use-package helm-projectile
      :delight (projectile-mode)
      :after helm
      :config
      (projectile-mode) ;; activate projectile-mode everywhere
      (helm-projectile-on)
      (setq projectile-mode-line-prefix " "
            projectile-completion-system 'helm
            projectile-require-project-root nil
            projectile-enable-caching t ;; enable caching for projectile-mode
            projectile-switch-project-action 'projectile-vc) ;; magit-status or svn
      (def-projectile-commander-method ?d
        "Open project root in dired."
        (projectile-dired))
      (def-projectile-commander-method ?f
        "Git fetch."
        (magit-status)
        (call-interactively #'magit-fetch-current)))
  #+END_SRC

* Tramp

  #+BEGIN_SRC emacs-lisp
    ;; cache file-name forever
    (setq remote-file-name-inhibit-cache nil)

    ;; make sure vc stuff is not making tramp slower
    (setq vc-ignore-dir-regexp
          (format "%s\\|%s"
                  vc-ignore-dir-regexp
                  tramp-file-name-regexp))

    (setq tramp-verbose 1) ;; only log errors
  #+END_SRC

* Date
  Date and time should be displayed in standard format, no M/D/Y nonsense.
  #+BEGIN_SRC emacs-lisp
     (setq display-time-day-and-date t ;; display date and time
           display-time-24hr-format t ;; 24h time format
           european-calendar-style t ;; day/month/year format for calendar
           calendar-week-start-day 1 ;; start week on Monday
           display-time-string-forms '((if (and (not display-time-format) display-time-day-and-date)
                                           (format-time-string "%H:%M, %a %d %b " now))))
     (display-time)
  #+END_SRC

  Add a hydra to insert the current date (and time) in various formats.
  #+BEGIN_SRC emacs-lisp
    (pretty-hydra-define hydra-dates
      (:color blue :quit-key "q")
      ("Insert date"
       (("s" ab/date-short (format-time-string "%d/%m/%Y"))
        ("d" ab/date-iso (format-time-string "%F"))
        ("D" ab/date-iso-with-day (format-time-string "%F %A"))
        ("l" ab/date-long (format-time-string "%d %B %Y"))
        ("L" ab/date-long-with-day (format-time-string "%A %d %B %Y"))
        ("o" ale/org-date (format-time-string "<%F %a>")))
       "Insert date & time"
       (("t" ab/date-short-with-time (format-time-string "%Y/%m/%d %H:%M"))
        ("T" ab/date-long-with-time (format-time-string "%A %d %B %Y - %H:%M") :width 33)
        ("i" ab/date-iso-with-time (format-time-string "%FT%T%z"))
        ("O" ale/org-date-time (format-time-string "<%F %a %H:%M>")))
       "Go to"
       (("g" ale/org-diary-goto-today (format-time-string "%F")))))

    (global-set-key (kbd "C-c d") 'hydra-dates/body)
  #+END_SRC

  I use [[https://github.com/kiwanami/emacs-calfw][calfw]] for a nice display of calendars.
  #+BEGIN_SRC emacs-lisp
    (use-package calfw
      :commands open-calendar
      :config
      (use-package calfw-gcal)
      (use-package calfw-cal)
      (use-package calfw-ical)
      (use-package calfw-org)
      (defun open-calendar ()
        (interactive)
        (cfw:open-calendar-buffer
         :contents-sources
         (list
          (cfw:ical-create-source "Google Calendar" my-private-primary-gcal-url "olive")
          (cfw:ical-create-source "Vacances" "http://dynical.com/iCal/weather.ics/?lng=fr&zone=ile-de-france|paris|75100&zone_=E" "yellow")
          (cfw:org-create-source "Green")  ; orgmode source
          ;; (cfw:cal-create-source "Orange") ; diary source
          (cfw:ical-create-source "Moon" "http://cantonbecker.com/astronomy-calendar/astrocal.ics" "Gray")  ; ICS source1
          ))))
  #+END_SRC

* Text
  #+BEGIN_SRC emacs-lisp
    (setq default-major-mode 'text-mode) ;; text-mode by default
    (add-hook 'text-mode-hook 'visual-line-mode) ;; auto-wrapping (soft wrap) in text-mode
    (remove-hook 'text-mode-hook #'turn-on-auto-fill) ;; visual-line-mode instead of auto-fill
  #+END_SRC

  Sometimes CSV mode can be useful:
  #+BEGIN_SRC emacs-lisp
    (use-package csv-mode
      :mode ".csv$")
  #+END_SRC

* Org-mode
  #+BEGIN_SRC emacs-lisp
    (use-package org
      :bind
      (("\C-c a" . org-agenda)
       ("\C-c b" . org-iswitchb)
       :map org-mode-map
       ("\C-c l" . org-store-link)
       ("\C-c j" . ale/jirify)
       ("\C-c r" . ale/rtify)
       ("\C-c t" . org-begin-template))
      :chords ("gx" . org-capture)
      :hook (org-mode . visual-line-mode)
      :config
      (use-package ob-restclient :defer t)
      (use-package ob-shell :ensure nil :defer t)
      (use-package htmlize :defer t)
      (use-package swagger-to-org :defer t)
      (require 'ox-md nil t)
      (require 'org-agenda)
      ;; specific agenda files
      (add-to-list 'org-agenda-files my-private-work-diary-org-file)
      (remove-hook 'text-mode-hook #'turn-on-auto-fill) ;; visual-line-mode instead of auto-fill
      (setq
       ;; general settings
       org-completion-use-ido t
       org-ellipsis " ▼"

       ;; html export
       org-export-html-style-include-scripts nil
       org-export-html-style-include-default nil
       org-html-htmlize-output-type 'css
       org-export-html-style "<link rel=\"stylesheet\" type=\"text/css\" href=\"org.css\" />"
       org-export-coding-system 'utf-8

       ;; active Babel languages
       org-confirm-babel-evaluate nil)
      (org-babel-do-load-languages 'org-babel-load-languages
                                   '((ledger . t)
                                     (shell . t)
                                     (sql . t)
                                     (restclient . t)
                                     (emacs-lisp . t)))
      ;; ORG-CAPTURE
      (setq notes-file (concat user-emacs-directory "notes.org")
            snippet-file (concat user-emacs-directory "code-snippets.txt")
            diary-local-file my-private-local-diary-file
            diary-remote-file (concat my-private-remote-home-dir my-private-remote-diary-org-file)
            todo-local-file my-private-local-todo-org-file
            todo-remote-file (concat my-private-remote-home-dir my-private-remote-todo-org-file)
            org-capture-templates
            '(;; local
              ("d" "diary item (local)" item (file+olp+datetree diary-local-file) "%i%?" :time-prompt t)
              ("n" "note       (local)" item (file+olp+datetree notes-file) "%i%?")
              ("t" "TODO       (local)" entry (file todo-local-file) "* TODO %?\n\t%i")
              ("y" "snippet    (local)\n" plain (file snippet-file) "\n--\n%i%?")
              ;; remote
              ("D" "diary item (remote)" item (file+olp+datetree diary-remote-file) "%i%?" :time-prompt t)
              ("T" "TODO       (remote)\n" entry (file+headline todo-remote-file "VRAC") "* TODO %?\n\t%i")))

      ;; font and faces customization
      (setq org-fontify-done-headline t)
      (custom-set-faces
       '(org-done ((t (:foreground "PaleGreen" :weight bold :strike-through t))))
       '(org-headline-done
         ((((class color) (min-colors 16) (background dark))
           (:foreground "dim grey" :strike-through t)))))
      (setq org-todo-keyword-faces
            '(("INPR" . (:foreground "yellow" :weight bold))
              ("STARTED" . (:foreground "yellow" :weight bold))
              ("WAIT" . (:foreground "yellow" :weight bold))
              ("WIP" . (:foreground "yellow" :weight bold))
              ("INPROGRESS" . (:foreground "yellow" :weight bold))))

      ;; teach french to date picker
      (setq parse-time-weekdays '(("sun" . 0)
                                  ("mon" . 1)
                                  ("tue" . 2)
                                  ("wed" . 3)
                                  ("thu" . 4)
                                  ("fri" . 5)
                                  ("sat" . 6)
                                  ("sunday" . 0)
                                  ("monday" . 1)
                                  ("tuesday" . 2)
                                  ("wednesday" . 3)
                                  ("thursday" . 4)
                                  ("friday" . 5)
                                  ("saturday" . 6)
                                  ("dim" . 0)
                                  ("lun" . 1)
                                  ("mar" . 2)
                                  ("mer" . 3)
                                  ("jeu" . 4)
                                  ("ven" . 5)
                                  ("sam" . 6)
                                  ("dimanche" . 0)
                                  ("lundi" . 1)
                                  ("mardi" . 2)
                                  ("mercredi" . 3)
                                  ("jeudi" . 4)
                                  ("vendredi" . 5)
                                  ("samedi" . 6)))
      (setq parse-time-months '(("jan" . 1)
                                ("feb" . 2)
                                ("mar" . 3)
                                ("apr" . 4)
                                ("may" . 5)
                                ("jun" . 6)
                                ("jul" . 7)
                                ("aug" . 8)
                                ("sep" . 9)
                                ("oct" . 10)
                                ("nov" . 11)
                                ("dec" . 12)
                                ("january" . 1)
                                ("february" . 2)
                                ("march" . 3)
                                ("april" . 4)
                                ("june" . 6)
                                ("july" . 7)
                                ("august" . 8)
                                ("september" . 9)
                                ("october" . 10)
                                ("november" . 11)
                                ("december" . 12)
                                ("fev" . 2)
                                ("fév" . 2)
                                ("avr" . 4)
                                ("mai" . 5)
                                ("jui" . 6)
                                ("juil" . 7)
                                ("aou" . 8)
                                ("sept" . 9)
                                ("déc" . 12)
                                ("janvier" . 1)
                                ("février" . 2)
                                ("fevrier" . 2)
                                ("mars" . 3)
                                ("avril" . 4)
                                ("juin" . 6)
                                ("juillet" . 7)
                                ("aout" . 8)
                                ("août" . 8)
                                ("septembre" . 9)
                                ("octobre" . 10)
                                ("novembre" . 11)
                                ("décembre" . 12)
                                ("decembre" . 12)))

      ;; update cookies [1/2] when deleting lines
      (defun myorg-update-parent-cookie ()
        (when (equal major-mode 'org-mode)
          (save-excursion
            (ignore-errors
              (org-back-to-heading)
              (org-update-parent-todo-statistics)))))

      (defadvice org-kill-line (after fix-cookies activate)
        (myorg-update-parent-cookie))

      (defadvice kill-whole-line (after fix-cookies activate)
        (myorg-update-parent-cookie)))
  #+END_SRC

  Use fancy bullets in org-mode:
  #+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
  #+END_SRC

* Special characters, spelling, i18n
** Spell checking
   #+BEGIN_SRC emacs-lisp
     (use-package my-checks
       :ensure nil
       :load-path "elisp/"
       :bind ("C-è" . hydra-spell/body)
       :commands dubcaps-mode
       :config
       (add-hook 'text-mode-hook 'flyspell-mode) ;; flyspell by default
       (add-hook 'text-mode-hook 'dubcaps-mode) ;; auto-correct double capitals

       (use-package define-word :defer t)
       (use-package guess-language :defer t)

       (pretty-hydra-define hydra-spell
         (:color teal :quit-key "q")
         ("Spelling"
          (("t" flyspell-mode "toggle flyspell")
           ("T" guess-language-mode "toggle guess"))
          "Flyspell"
          (("a" endless/ispell-word-then-abbrev "Correct & add")
           ("c" flyspell-buffer "check buffer")
           ("n" flyspell-goto-next-error "next error" :color pink)
           ("p" flyspell-goto-previous-error "previous error" :color pink)
           ("l" define-word-at-point "lookup word"))
          "Dictionary"
          (("d" ispell-change-dictionary "choose")
           ("f" ale/switch-to-fr-dict "fr_FR")
           ("e" ale/switch-to-en-dict "en_GB")
           ("u" ale/switch-to-us-dict "en_US")
           ("g" guess-language "guess")))))
   #+END_SRC

** Synonyms
   #+BEGIN_SRC emacs-lisp
     (use-package powerthesaurus :defer t)
   #+END_SRC

** Grammalecte
   #+BEGIN_SRC emacs-lisp
     (use-package grammalecte
       :disabled
       :ensure nil
       :load-path "../projets/yet-an-other-flycheck-grammalecte-fork/")
   #+END_SRC

* Programming
** Formatting
   #+BEGIN_SRC emacs-lisp
     (use-package prog-fill
       :bind (:map prog-mode-map
                   ("M-q" . prog-fill)))

     ;; prettify-symbols
     (defconst prettify-symbols-alist
       '(("lambda"  . ?λ)
         ("!=" . ?≠)
         ("<=" . ?≤)
         (">=" . ?≥)
         ("!=" . ?≠)
         ("->" . ?→)
         ("<-" . ?←)
         ("=>" . ?⇒)
         ("..." . ?…)))
     (add-hook 'prog-mode-hook 'prettify-symbols-mode)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package format-all :defer t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (reformatter-define xml-format
       :program "xmllint"
       :args '("--format" "-")
       :mode nil)
   #+END_SRC

** Flycheck
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :hook (prog-mode . flycheck-mode))
   #+END_SRC

** LSP

   TODO: describe lsp
   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :defer t
       :config
       (setq lsp-prefer-flymake nil)) ;; flycheck instead of flymake

     (use-package company-lsp
       :defer t
       :requires lsp company)

     (use-package lsp-ui
       :requires lsp-mode flycheck
       :hook (lsp-mode . lsp-ui-mode)
       :config
       (setq lsp-ui-doc-enable t
             lsp-ui-doc-use-childframe t
             lsp-ui-doc-position 'top
             lsp-ui-doc-include-signature t
             lsp-ui-sideline-enable nil
             lsp-ui-sideline-update-mode 'point
             lsp-ui-sideline-ignore-duplicate t
             lsp-ui-flycheck-enable t
             lsp-ui-flycheck-list-position 'right
             lsp-ui-flycheck-live-reporting t
             lsp-ui-peek-enable t
             lsp-ui-peek-list-width 60
             lsp-ui-peek-peek-height 25))

     (use-package treemacs :defer t)

     (use-package helm-lsp :defer t)

     (use-package dap-mode
       :defer t
       :requires lsp-mode
       :config
       (dap-mode 1)
       (dap-ui-mode 1))
   #+END_SRC

** Dealing with parens
   I tried paredit, didn’t really like the “strict” thing. Hope will get used to smartparens
   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :hook ((prog-mode markdown-mode) . turn-on-smartparens-mode)
       :commands smartparens-mode
       :bind (
              :map lisp-mode-map
              ("C-M-f" . sp-forward-sexp)
              ("C-M-b" . sp-backward-sexp)
              :map emacs-lisp-mode-map
              ("C-M-f" . sp-forward-sexp)
              ("C-M-b" . sp-backward-sexp)
              :map lisp-interaction-mode-map
              ("C-M-f" . sp-forward-sexp)
              ("C-M-b" . sp-backward-sexp)
              :map emacs-lisp-mode-map
              ("C-M-f" . sp-forward-sexp)
              ("C-M-b" . sp-backward-sexp))
       :config
       (require 'smartparens-config)
       (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
       (defmacro def-pairs (pairs)
         `(progn
            ,@(loop for (key . val) in pairs
                    collect
                    `(defun ,(read (concat
                                    "wrap-with-"
                                    (prin1-to-string key)
                                    "s"))
                         (&optional arg)
                       (interactive "p")
                       (sp-wrap-with-pair ,val)))))
       ;; (sp-local-pair 'emacs-lisp-mode "`" "'") ;; adds `' as a local pair in emacs-lisp-mode
       ;; (sp-local-pair 'emacs-lisp-mode "`" "'") ;; adds `' as a local pair in emacs-lisp-mode
       ;; (sp-local-pair '(tex-mode latex-mode) "{" "}") ;; adds `' as a local pair in emacs-lisp-mode
       ;; (sp-pair '(tex-mode latex-mode) "{" "}") ;; adds `' as a local pair in emacs-lisp-mode
       (sp-pair "<" ">")
       (sp-pair "≤" "≥")
       (sp-pair "«" "»")
       (sp-pair "“" "”")
       (sp-pair "‘" "’")
       (def-pairs ((paren . "(")
                   (bracket . "[")
                   (brace . "{")
                   (angle . "<")
                   (angle-eq . "≤")
                   (single-quote . "'")
                   (double-quote . "\"")
                   (guillemet . "«")
                   (curly-double-quote . "“")
                   (curly-single-quote . "‘")
                   (back-quote . "`")))
       (global-set-key (kbd "M-s (") 'wrap-with-parens)
       (global-set-key (kbd "M-s [") 'wrap-with-brackets)
       (global-set-key (kbd "M-s {") 'wrap-with-braces)
       (global-set-key (kbd "M-s <") 'wrap-with-angles)
       (global-set-key (kbd "M-s ≤") 'wrap-with-angle-eqs)
       (global-set-key (kbd "M-s '") 'wrap-with-single-quotes)
       (global-set-key (kbd "M-s \"") 'wrap-with-double-quotes)
       (global-set-key (kbd "M-s «") 'wrap-with-guillemets)
       (global-set-key (kbd "M-s “") 'wrap-with-curly-double-quotes)
       (global-set-key (kbd "M-s ‘") 'wrap-with-curly-single-quotes)
       (global-set-key (kbd "M-s `") 'wrap-with-back-quotes)
       (global-set-key (kbd "M-s w") 'sp-rewrap-sexp)

       (pretty-hydra-define hydra-parens
         (:color teal :quit-key "q")
         ("Insert"
          (("c" sp-clone-sexp "clone")
           ("p" sp-split-sexp "split"))
          "Delete"
          (("k" sp-kill-sexp "kill")
           ("C-k" sp-kill-hybrid-sexp "kill hybrid")
           ("r" sp-raise-sexp "raise")
           ("s" sp-splice-sexp "splice")
           ("M-s" sp-splice-sexp "splice"))
          "Transpose"
          (("t" sp-transpose-sexp "transpose")
           ("T" sp-transpose-hybrid-sexp "transpose hybrid")
           ("w" sp-rewrap-sexp "rewrap"))
          "Slurp"
          (("a" sp-absorb-sexp "absorb")
           ("j" sp-join-sexp "join")
           ("(" sp-backward-slurp-sexp "slurp backward")
           (")" sp-slurp-hybrid-sexp "slurp hybrid"))
          "Barf"
          (("e" sp-emit-sexp "emit")
           ("«" sp-backward-barf-sexp "barf backward")
           ("»" sp-forward-barf-sexp "barf forward"))))
       (global-set-key (kbd "M-s M-s") 'hydra-parens/body))
   #+END_SRC

** Shell
   #+BEGIN_SRC emacs-lisp
     (add-hook 'sh-mode-hook (lambda () (setq tab-width 2 sh-basic-offset 2 indent-tabs-mode t)))
     (add-hook 'sh-mode-hook 'flycheck-mode)
     (use-package shx :defer t)
     ;;(autoload 'sh-mode "sh-mode" "Major mode for editing shell scripts." t)
     (add-to-list 'auto-mode-alist '(".*rc$" . sh-mode))
     (add-to-list 'auto-mode-alist '(".*bash.*$" . sh-mode))

     (use-package fish-mode
       :mode ("\\.fish$" . fish-mode)
       :hook (fish-mode . flycheck-mode)
       :config (setq tab-width 2
                     sh-basic-offset 2
                     fish-indent-offset 2
                     indent-tabs-mode t))

     ;; Normal tab completion in Eshell
     (setq eshell-cmpl-cycle-completions nil)

     ;; another C-d in shell kills shell buffer
     (defun comint-delchar-or-eof-or-kill-buffer (arg)
       (interactive "p")
       (if (null (get-buffer-process (current-buffer)))
           (kill-buffer)
         (comint-delchar-or-maybe-eof arg)))

     (add-hook 'shell-mode-hook
               (lambda ()
                 (define-key shell-mode-map
                   (kbd "C-d") 'comint-delchar-or-eof-or-kill-buffer)))

     (use-package shell-pop
       :bind (:map shell-mode-map ("C-c C-l" . helm-comint-input-ring))
       :config
       (setq shell-pop-default-directory nil)
       (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda () (ansi-term shell-pop-term-shell)))))
       (setq shell-pop-term-shell "/bin/bash")
       ;;(setq shell-pop-universal-key "C-t")
       (setq shell-pop-window-size 30)
       (setq shell-pop-full-span t)
       (setq shell-pop-window-position "bottom")
       ;; need to do this manually or not picked up by `shell-pop'
       (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
   #+END_SRC

   Just in case, make sure we can edit with:
   #+BEGIN_QUOTE
   The One True,\\
   The Right honorable,\\
   The Standard Editor,\\
   Edward '[[https://lambdaisland.com/episodes/ultimate-dev-setup][ed(1)]]' Editor
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
     (use-package ed-mode
       :ensure nil
       :commands ed
       :load-path "elisp/")
   #+END_SRC

** Lisp
   #+BEGIN_SRC emacs-lisp
     (use-package lisp-mode
       :ensure nil
       :config (flycheck-mode t)
       :bind (:map lisp-mode-map
                   ("C-c C-c" . eval-region)
                   ("C-c C-r" . crux-eval-and-replace)))

     (use-package elisp-mode
       :ensure nil
       :bind (:map emacs-lisp-mode-map
                   ("C-c C-c" . eval-region)
                   ("C-c C-r" . crux-eval-and-replace)))

     (use-package ielm
       :ensure nil
       :hook (ielm-mode . (lambda () (setq-local scroll-margin 0))))

     (use-package elisp-slime-nav
       :after emacs-lisp-mode
       :hook (emacs-lisp-mode-hook))
   #+END_SRC

   Litable mode allows quick elisp code evaluation.
   #+BEGIN_SRC emacs-lisp
     (use-package litable
       :hook (lisp-interaction-mode . litable-mode))
   #+END_SRC

** Clojure
   #+BEGIN_SRC emacs-lisp
   (use-package clojure-mode
     :disabled
     :config
     (use-package cider)
     (use-package helm-cider)

     ;; (setq cider-font-lock-dynamically nil)
     (setq cider-repl-use-pretty-printing t
           helm-cider-mode t))
   #+END_SRC

** Sql
   #+BEGIN_SRC emacs-lisp
     (use-package sql
       :ensure nil
       :hook
       (sql-mode . (lambda () (setq-local truncate-lines nil)))
       (sql-mode . (lambda () (aggressive-indent-mode 0)))
       (sql-mode . (lambda () (setq-local linesize 9999)))
       (sql-interactive-mode . (lambda () (progn
                                       (setq-local comint-output-filter-functions 'comint-truncate-buffer)
                                       (setq-local comint-buffer-maximum-size 5000)
                                       (setq-local comint-scroll-show-maximum-output t)
                                       (setq-local comint-input-ring-size 500))))
       :mode (("\\.sql\\'" . sql-mode)
              ("\\.pks\\'" . sql-mode)
              ("\\.pkb\\'" . sql-mode)
              ("\\.mvw\\'" . sql-mode)
              ("\\.con\\'" . sql-mode)
              ("\\.ind\\'" . sql-mode)
              ("\\.sqs\\'" . sql-mode)
              ("\\.tab\\'" . sql-mode)
              ("\\.trg\\'" . sql-mode)
              ("\\.vw\\'" .  sql-mode)
              ("\\.prc\\'" . sql-mode)
              ("\\.pk\\'" .  sql-mode)))

     (use-package sqlformat)

     (use-package sql-indent
       :ensure nil
       :load-path "elisp/")

     (use-package sql-upcase
       :ensure nil
       :load-path "elisp/"
       :hook (sql-mode . sql-upcase-mode))

     (pretty-hydra-define hydra-format-sql
       (:color blue :quit-key "q")
       ("Format"
        (("f" sqlformat "paragraph")
         ("b" sqlformat-buffer "buffer")
         ("r" sqlformat-region "region")
         ("i" sql-indent-buffer "indent"))
        "Upcase"
        (("u" sql-upcase-buffer "buffer")
         ("U" sql-upcase-region "region"))))
     (global-set-key (kbd "C-c C-f") 'hydra-format-sql/body)
   #+END_SRC

** Groovy
   #+BEGIN_SRC emacs-lisp
     (use-package groovy-mode
       :mode ("\\.groovy\\'" "\\.gradle\\'")
       :config (setq groovy-indent-offset 2))
   #+END_SRC

** Ruby
   #+BEGIN_SRC emacs-lisp
     (use-package ruby-mode
       :mode "\\.rb\\'"
       :interpreter "ruby")
   #+END_SRC

** Rust
   #+BEGIN_SRC emacs-lisp
     (use-package cargo
       :config (add-to-list 'exec-path (concat (getenv "HOME") "/.cargo/bin")))

     (use-package rust-mode
       :hook
       (rust-mode . cargo-minor-mode)
       (rust-mode . racer-mode)
       (racer-mode . company-mode)
       :config
       (use-package flycheck-rust)
       (use-package racer
         :defer t
         :config
         (setq company-tooltip-align-annotations t)
         (local-set-key (kbd "TAB") #'company-indent-or-complete-common)
         ;; (setq racer-rust-src-path (concat (getenv "HOME") "/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib"))
         )
       (flycheck-rust-setup))
   #+END_SRC

** Scala
   #+BEGIN_SRC emacs-lisp
     (use-package ensime :defer t)
     (use-package sbt-mode :defer t)
     (use-package scala-mode :defer t)
   #+END_SRC

** Java
   Enable flycheck for Java:
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-java ;; flycheck minor mode for java
       :disabled
       :ensure nil
       :load-path "elisp/"
       :hook (java-mode))
   #+END_SRC

*** TODO malabar-mode (à tester)
    #+BEGIN_SRC emacs-lisp
      (use-package malabar-mode
        :disabled
        :config
        ;; JAVA (malabar-mode)
        ;; mimic the IDEish compile-on-save behaviour
        ;; (load-file "~/outils/cedet/cedet-devel-load.el")
        (load-file "~/projets/malabar-mode/src/main/lisp/malabar-mode.el")
        (load-file "~/projets/cedet/cedet-devel-load.el")
        (add-hook 'after-init-hook (lambda ()
                                     (message "activate-malabar-mode")
                                     (activate-malabar-mode)))

        (add-hook 'malabar-java-mode-hook 'flycheck-mode)
        (add-hook 'malabar-groovy-mode-hook 'flycheck-mode)
        (add-hook 'malabar-mode-hook (lambda () (add-hook 'after-save-hook 'malabar-compile-file-silently nil t)))
        (add-hook 'malabar-mode-hook
                  (lambda ()
                    (add-hook 'after-save-hook 'malabar-http-compile-file-silently
                              nil t))))
    #+END_SRC

*** TODO eclim (à tester)
    #+BEGIN_SRC emacs-lisp
      (use-package eclim
        :disabled
        :config
        (global-eclim-mode)
        (require 'eclimd)
        (setq eclim-eclipse-dirs "~/outils/eclipse/eclipse-mars"
              eclim-executable "~/outils/eclipse/eclipse-mars/eclim")
        ;; (require 'company)
        (require 'company-emacs-eclim)
        (global-company-mode t)
        (company-emacs-eclim-setup)
        ;; (company-emacs-eclim-ignore-case t)
        (add-hook 'java-mode-hook (lambda () (setq flycheck-java-ecj-jar-path "/home/arthur/outils/java/ecj-4.5.jar")))
        (add-hook 'java-mode-hook 'eclim-mode))
    #+END_SRC

*** ecb (à tester)
    #+BEGIN_SRC emacs-lisp
      (use-package ecb :disabled
        :config  (setq ecb-options-version "2.40"))
    #+END_SRC

*** lsp-java
    #+BEGIN_SRC emacs-lisp
      (use-package lsp-java
        ;; :delight (java-mode "🅹" :major)
        :bind ("C-S-o" . lsp-execute-code-action)
        :after lsp
        :config (add-hook 'java-mode-hook 'lsp))

      (use-package dap-java
        :defer t
        :ensure nil
        :after lsp-java)

      (use-package lsp-java-treemacs
        :defer t
        :ensure nil
        :after treemacs)
    #+END_SRC

*** meghanada
    #+BEGIN_SRC emacs-lisp
      (use-package autodisass-java-bytecode
        :disabled
        :defer t)

      (use-package google-c-style
        :disabled
        :commands google-set-c-style)

      (use-package meghanada
        :disabled
        :commands
        (meghanada-mode)
        :bind
        (:map meghanada-mode-map
              ("M-m" . hydra-meghanada/body))
        :hook
        (java-mode . (lambda ()
                       ;; meghanada-mode on
                       (meghanada-mode t)
                       (flycheck-mode +1)
                       (setq c-basic-offset 4)))
        (before-save . meghanada-code-beautify-before-save)
        :config
        (use-package realgud ;; I don't even know what this package is or does
          :disabled)
        (setq indent-tabs-mode nil
              tab-width 4
              c-basic-offset 4
              meghanada-server-remote-debug t
              meghanada-javac-xlint "-Xlint:all,-processing"
              meghanada-java-path "java"
              meghanada-maven-path "mvn")
        :pretty-hydra
        ((:color teal :quit-key "q")
         ("Meghanada"
          (("M-m" meghanada-restart "restart")
           ("." meghanada-reference "reference")
           ("h" meghanada-typeinfo "type info"))
          "Compile"
          (("f" meghanada-compile-file "file")
           ("c" meghanada-compile-project "project"))
          "Edit"
          (("o" meghanada-optimize-import "organise imports")
           ("i" meghanada-import-all "import all")
           ("v" meghanada-local-variable))
          "Run & test"
          (("R" meghanada-run-task "run task")
           ("t" meghanada-run-junit-test-case "run JUnit test case")
           ("T" meghanada-run-junit-class "run JUnit class")
           ("r" meghanada-run-junit-recent "run JUnit recent")
           ("s" meghanada-switch-test-case "switch test case")))))

    #+END_SRC

** Javascript
   #+BEGIN_SRC emacs-lisp
     (use-package js2-mode
       ;; :bind (:js2-mode-map ("C-c C-c" . compile))
       :mode ("\\.js\\'\\|\\.json\\'" . js2-mode)
       :hook ((json-mode . json-pretty-print)
              (js2-mode . json-pretty-print-buffer)
              (js2-mode . aggressive-indent-mode)
              (js2-mode . js2-refactor-mode))
       :config
       (use-package js2-refactor
         :config
         (js2r-add-keybindings-with-prefix "C-c C-r")
         (setq js2-skip-preprocessor-directives t))
       (setq js2-basic-offset 2
             js-indent-level 2
             js2-use-font-lock-faces t)
       (add-hook 'js2-mode-hook (lambda () (flycheck-mode t)))
       (autoload 'json-pretty-print "json-pretty-print" "json-pretty-print" t))

     ;; à tester
     (use-package js-comint
       :disabled
       :config  (defun inferior-js-mode-hook-setup ()
                  (add-hook 'comint-output-filter-functions 'js-comint-process-output))
       (add-hook 'inferior-js-mode-hook 'inferior-js-mode-hook-setup t)
       (add-hook 'js2-mode-hook
                 (lambda ()
                   (local-set-key (kbd "C-x C-e") 'js-send-last-sexp)
                   (local-set-key (kbd "C-M-x") 'js-send-last-sexp-and-go)
                   (local-set-key (kbd "C-c b") 'js-send-buffer)
                   (local-set-key (kbd "C-c C-b") 'js-send-buffer-and-go)
                   (local-set-key (kbd "C-c l") 'js-load-file-and-go))))
   #+END_SRC

** JSON
   #+BEGIN_SRC emacs-lisp
     (use-package json-reformat
       :bind (:map prog-mode-map
                   ("C-c j" . json-reformat-region))
       :config (setq json-reformat:indent-width js2-basic-offset))
   #+END_SRC

** Web
   #+BEGIN_SRC emacs-lisp
     (use-package web-mode ;; HTML, XML, JSP (using web-mode)
       :config
       (setq web-mode-markup-indent-offset 2
             web-mode-code-indent-offset 2
             web-mode-enable-auto-indentation t
             web-mode-enable-auto-quoting t
             web-mode-engines-alist '(("php" . "\\.phtml\\'")
                                      ("blade" . "\\.blade\\.")))
       :mode ("\\.phtml\\'"
              "\\.tpl\\.php\\'"
              "\\.[agj]sp\\'"
              "\\.as[cp]x\\'"
              "\\.erb\\'"
              "\\.js\\'"
              "\\.jsx\\'"
              "\\.json\\'"
              "\\.mustache\\'"
              "\\.djhtml\\'"
              "\\.rhtml\\'"
              "\\.htm\\'"
              "\\.html\\'"
              "\\.tag\\'"
              "\\.tmpl\\'"
              "\\.tsx\\'"
              "\\.xml\\'"
              "\\.xsd\\'"
              "\\.wsdl\\'"))

     (defun mu-xml-format ()
       "Format an XML buffer with `xmllint'."
       (interactive)
       (shell-command-on-region (point-min) (point-max)
                                "xmllint -format -"
                                (current-buffer) t
                                "*Xmllint Error Buffer*" t))
     (use-package web-beautify
       :disabled
       :bind-keymap (
                     ;; :map js2-mode-map ("C-c b" . web-beautify-js)
                     ;; Or if you're using 'js-mode' (a.k.a 'javascript-mode')
                     :map js-mode-map ("C-c b" . web-beautify-js)
                     :map json-mode-map ("C-c b" . web-beautify-js)
                     :map html-mode-map ("C-c b" . web-beautify-html)
                     :map web-mode-map ("C-c b" . web-beautify-html)
                     :map css-mode-map ("C-c b" . web-beautify-css)))
   #+END_SRC

   [[https://github.com/skeeto/impatient-mode][Impatient-mode]] enables live editing of html files.
   #+BEGIN_SRC emacs-lisp
     (use-package impatient-mode :defer t)
   #+END_SRC

** Typescript
   #+BEGIN_SRC emacs-lisp
     (use-package tide
       :disabled
       :chords (:map tide-mode-map
                     ("+-" . bury-buffer))
       :bind (:map tide-mode-map
                   ("C-c k" . bury-buffer)
                   ("C-." . tide-jump-to-definition)
                   ("C-," . tide-jump-back)
                   ("C-c C-c" . hydra-tide/body))
       :hook
       ;; formats the buffer before saving
       (before-save . tide-format-before-save)
       (typescript-mode . setup-tide-mode)
       (typescript-mode . rainbow-blocks-mode)
       (js2-mode . setup-tide-mode)
       :config
       (defun setup-tide-mode ()
         (interactive)
         (tide-setup)
         (flycheck-mode +1)
         (setq flycheck-check-syntax-automatically '(save mode-enabled))
         ;; flycheck-typescript-tslint-executable "tslint"
         ;; (eldoc-mode +1)
         (company-mode +1))

       (setq company-tooltip-align-annotations t  ;; aligns annotation to the right hand side
             typescript-indent-level 2
             ;; format options
             tide-format-options '(
                                   :insertSpaceAfterFunctionKeywordForAnonymousFunctions t
                                   :placeOpenBraceOnNewLineForFunctions nil))

       ;; (setq tide-tsserver-process-environment '("TSS_LOG=-level verbose -file ~/projets/tss.log"))
       :pretty-hydra
       ((:color blue :quit-key "q")
        ("Tide"
         (("s" tide-restart-server "restart server"))
         "Edit"
         (("r" tide-rename-symbol "rename")
          ("f" tide-format "format"))
         "Navigate"
         (("e" tide-project-errors "errors")
          ("g" tide-references "references")))))

     (use-package typescript-mode
       :disabled
       :mode ("\\.ts\\'"
              "\\.json\\'"))

     (use-package sass-mode
       :mode ("\\.sass$" . sass-mode))
   #+END_SRC

** Python
   #+BEGIN_SRC emacs-lisp
     (use-package python
       :bind (:map python-mode-map
                   ("M-g M-p" . flycheck-previous-error)
                   ("M-g M-n" . flycheck-next-error)
                   ("C-x C-e" . python-shell-send-defun))
       :hook (python-mode . (lambda () (progn
                                    (elpy-enable)
                                    (elpy-mode)
                                    (flycheck-mode))))
       :config
       (setq python-indent-offset 4
             tab-always-indent t)

       (use-package jedi
         :defer t
         :config (setq jedi:complete-on-dot t))

       (use-package elpy
         :defer t
         :config
         (delete "elpy-module-flymake" elpy-modules) ;; use flycheck instead
         (setq elpy-rpc-backend "jedi"))) ;; fire up jedi in python env
   #+END_SRC

** Yaml
   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :mode ("\\.yml\\'" . yaml-mode))
   #+END_SRC

** Crontab
   #+BEGIN_SRC emacs-lisp
     (use-package crontab-mode
       :mode ("\\.crontab\\'" . crontab-mode))
   #+END_SRC

** Markdown
   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :mode ("\\.md\\'" . markdown-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package grip-mode :defer t)
   #+END_SRC

** Dokuwiki
   #+BEGIN_SRC emacs-lisp
     (use-package dokuwiki-mode
       :defer t)
     (use-package dokuwiki
       :hook dokuwiki-mode)
   #+END_SRC

** LaTeX
   #+BEGIN_SRC emacs-lisp
     (use-package tex
       :defer t
       :ensure auctex
       :config
       (use-package auctex-latexmk
         :config
         (auctex-latexmk-setup)
         (TeX-global-PDF-mode t)))
   #+END_SRC

** Gradle
   #+BEGIN_SRC emacs-lisp
     (use-package gradle-mode :defer t)
   #+END_SRC

** Docker
   #+BEGIN_SRC emacs-lisp
     (use-package docker :defer t)
     (use-package dockerfile-mode :defer t)
   #+END_SRC

** Logs
   #+BEGIN_SRC emacs-lisp
     (use-package syslog-mode
       :mode ("\\.log\\'" "\\.out\\'")
       :config
       (add-to-list 'revert-without-query "\\.log\\'")
       (add-to-list 'revert-without-query "\\.out\\'"))
   #+END_SRC

* Mail
  #+BEGIN_SRC emacs-lisp
    ;; (remove-hook 'html-helper-mode-hook 'flyspell-mode) ;; auto-correct disabled by default
    (add-hook 'mail-mode-hook 'visual-line-mode) ;; wrapping in mail-mode
  #+END_SRC

  Let’s use emacs to read our mail (with mu4e) :
  #+BEGIN_SRC emacs-lisp
    (use-package mu4e
      :load-path "/usr/share/emacs/site-lisp/mu4e"
      :ensure nil
      :commands mu4e
      :config
      (setq mu4e-maildir (expand-file-name "~/Maildir")
            mu4e-drafts-folder "/[Gmail].Drafts"
            mu4e-sent-folder   "/[Gmail].Sent Mail"
            mu4e-trash-folder  "/[Gmail].Trash"

            ;; don't save message to Sent Messages, GMail/IMAP will take care of this
            mu4e-sent-messages-behavior 'delete

            ;; setup some handy shortcuts
            mu4e-maildir-shortcuts
            '(("/INBOX"             . ?i)
              ("/[Gmail].Starred"   . ?s)
              ("/[Gmail].Sent Mail" . ?t)
              ("/[Gmail].Trash"     . ?b))

            ;; allow for updating mail using 'U' in the main view:
            mu4e-get-mail-command "offlineimap"

            ;; something about ourselves
            user-mail-address my-private-mail-address
            user-full-name my-private-full-name
            ;; I don't use a signature…
            message-signature (concat "\n-- \n" my-private-full-name)))
  #+END_SRC

  I send email using smtpmail. We have to make sure the gnutls command line utils are installed; package 'gnutls-bin' in Debian/Ubuntu, 'gnutls' in Archlinux.
  #+BEGIN_SRC emacs-lisp
    (use-package smtpmail
      :ensure nil
      :defer t
      :config (setq message-send-mail-function 'smtpmail-send-it
                    starttls-use-gnutls t
                    smtpmail-starttls-credentials '((my-private-smtp-server my-private-smtp-server-port nil nil))
                    smtpmail-auth-credentials (expand-file-name my-private-auth-file)
                    smtpmail-default-smtp-server my-private-smtp-server
                    smtpmail-smtp-server my-private-smtp-server
                    smtpmail-smtp-service my-private-smtp-server-port
                    smtpmail-debug-info t))
  #+END_SRC

* Web browsing
  I use eww to surf the web in emacs, for simple pages mostly:
  #+BEGIN_SRC emacs-lisp
    (use-package eww
      :defer t
      :config
      (setq browse-url-generic-program "firefox"
            browse-url-browser-function 'eww-browse-url ;; set default browser to eww, then ‘&’ to open page firefox
            shr-external-browser 'browse-url-firefox
            shr-width 100 ;; keep sane layout
            shr-use-fonts t ;; no fancy fonts in text mode
            gnus-button-url 'browse-url-generic))
  #+END_SRC

* Quick access
** Custom menu

   Let’s define a few hydras to manage global settings. First, a general hydra for all minor modes that can be toggled:
   #+BEGIN_SRC emacs-lisp
     (pretty-hydra-define hydra-toggles
       (:color blue :quit-key "q")
       ("Navigation"
        (("B" beginend-global-mode "begin-end" :toggle t)
         ("i" ido-mode "ido" :toggle t)
         ("l" linum-mode "line number" :toggle t)
         ("r" linum-relative-global-mode "relative line numbers" :toggle t)
         ("M" minimap-mode "minimap" :toggle t)
         ("t" treemacs "treemacs")
         ("v" visual-line-mode "visual line" :toggle t)
         ("x" winnow-mode "winnow" :toggle t))
        "Highlighting"
        (("b" beacon-mode "beacon" :toggle t)
         ("h" idle-highlight-mode "Idle HL" :toggle t)
         ("H" hl-line-mode "highlight line" :toggle t)
         ("I" highlight-indent-guides-mode "indent guide" :toggle t)
         ("m" hide-mode-line-mode "hide mode-line" :toggle t)
         ("V" volatile-highlights-mode "volatile highlight" :toggle t))
        "Decoration"
        (("C" color-identifiers-mode "color identifiers" :toggle t)
         ("G" grip-mode "md/org preview" :toggle t)
         ("p" prettify-symbols-mode "prettify symbols" :toggle t)
         ("R" rainbow-blocks-mode "rainbow blocks" :toggle t)
         ("P" prism-mode "prism" :toggle t)
         ("w" whitespace-mode "whitespace" :toggle t)
         ("z" bzg-big-fringe-mode "zen" :toggle t))
        "Coding"
        (("a" aggressive-indent-mode "aggressive indent" :toggle t)
         ("(" smartparens-global-mode "smartparens" :toggle t)
         (")" smartparens-global-strict-mode "smartparens strict" :toggle t)
         ("f" flycheck-mode "flycheck" :toggle t)
         ("L" litable-mode "litable" :toggle t))
        "Writing"
        (("A" global-auto-revert-mode "auto-revert" :toggle t)
         ("c" company-mode "company" :toggle t)
         ("d" dubcaps-mode "dubcaps" :toggle t)
         ("F" flyspell-mode "flyspell" :toggle t)
         ("g" toggle-god-mode "god" :toggle god-local-mode)
         ("o" overwrite-mode "overwrite" :toggle t)
         ("s" superword-mode "super-word" :toggle t))))
     (global-set-key (kbd "C-c m") 'hydra-toggles/body)
     (global-set-key (kbd "C-é") 'hydra-toggles/body)
   #+END_SRC

   Then an other hydra for quickly switching to the major modes I use the most:
   #+BEGIN_SRC emacs-lisp
     (pretty-hydra-define hydra-major-modes
       (:color blue :quit-key "q")
       ("Prog"
        (("e" emacs-lisp-mode "elisp")
         ("l" lisp-mode "lisp")
         ("J" java-mode "Java")
         ("p" python-mode "python")
         ("r" ruby-mode "ruby")
         ("R" rust-mode "rust")
         ("s" sql-mode "SQL")
         )
        "Web"
        (("h" html-mode "html")
         ("c" css-mode "css")
         ("j" js2-mode "js2")
         ("n" nxml-mode "nXml")
         ("w" web-mode "web"))
        "Text"
        (("," csv-mode "csv")
         ("o" org-mode "org")
         ("t" text-mode "text"))))
     (global-set-key (kbd "C-c M") 'hydra-major-modes/body)
   #+END_SRC

   Finally, a last hydra to manage all kinds of stuff I use often: opening shell buffers, some specific files…
   #+BEGIN_SRC emacs-lisp
     (pretty-hydra-define hydra-widgets
       (:color blue :quit-key "q")
       ("Shells"
        (("e" eshell "eshell")
         ("t" shell-pop "shell-pop")
         ("$" shell "shell")
         ("%" crux-visit-term-buffer "ansi-term"))
        "Reading"
        (("a" avandu-overview "avandu RSS")
         ("A" helm-lobsters "lobsters")
         ("E" elfeed "elfeed RSS")
         ("G" gnus "Gnus")
         ("W" eww "web browser"))
        "Management"
        (("m" mu4e "mu4e")
         ("c" open-calendar "calendar")
         ("T" tomatinho "pomodoro"))
        "Diff"
        (("E" ediff "ediff")
         ("z" ztree-diff "ztree-diff")
         ("b" ale/ediff-current-buffers "quick diff")
         ("y" ale/diff-last-2-yanks "diff yanks"))
        "Tools"
        (("p" package-list-packages "packages")
         ("Q" quick-calc "quick-calc")
         ("f" format-all-buffer "format buffer")
         ("w" webpaste-paste-region "webpaste"))
        "Files"
        (("d" ale/find-diary-file "diary" :column "Files")
         ("D" ale/find-remote-diary-file "remote diary")
         ("i" ale/find-init-file "init file")
         ("r" ale/find-rest-client-file "rest-client"))))

     (key-chord-define-global (kbd "bj") 'hydra-widgets/body)
   #+END_SRC

** Bookmarks and registers
   #+BEGIN_SRC emacs-lisp
     (key-chord-define-global (kbd "jj") 'jump-to-register)
   #+END_SRC
* Environment
  #+BEGIN_SRC emacs-lisp
    (load-file (expand-file-name "env.el" user-emacs-directory))
  #+END_SRC

* Mode-line
  I want to be able to hide the mode-line entirely.
  #+BEGIN_SRC emacs-lisp
    (use-package hide-mode-line)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package modeline-posn
      :ensure nil
      :load-path "elisp/"
      :config (load-library "modeline-posn.el"))
  #+END_SRC

  Let’s have an indicator in the mode-line for search results:
  #+BEGIN_SRC emacs-lisp
    (use-package anzu
      :config
      (global-anzu-mode t)
      (setq-default anzu-cons-mode-line-p t))
  #+END_SRC

  After several attempts to switch to fancier packages such as [[https://github.com/milkypostman/powerline][powerline]], [[https://github.com/TheBB/spaceline][spaceline]] or [[https://github.com/dbordak/telephone-line][telephone-line]], I went back to [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]], which loads faster and fulfils most of my needs. [[https://github.com/Malabarba/rich-minority][rich-minority]] manages what minor modes should be displayed in the modeline.

  #+BEGIN_SRC emacs-lisp
    (use-package sml-modeline
      :config
      (setq sml-modeline-borders nil
            sml-modeline-mode t
            sml-modeline-numbers 'percentage)
      (sml-modeline-mode))

    (use-package smart-mode-line
      :config
      ;; for issues with theme loading
      (size-indication-mode)
      (setq sml/battery-format "%p"
            sml/col-number-format "%1c"
            sml/extra-filler 0
            sml/full-mode-string " …"
            sml/line-number-format "%1l"
            sml/mule-info "%z"
            sml/name-width '(15 . 44)
            sml/pos-id-separator ""
            sml/position-percentage-format nil
            sml/shorten-mode-string ""
            sml/shorten-modes nil
            sml/size-indication-format "(%I) "
            sml/theme 'dark
            sml/use-projectile-p 'before-prefixes
            sml/replacer-regexp-list '(("^~/projets/" ":p:")
                                       ("^~/\\.emacs\\.d/elpa/" ":ELPA:")
                                       ("^~/\\.emacs\\.d/" ":ED:")
                                       ("^/sudo:.*:" ":SU:")
                                       ("^~/Terminalcity/" ":T:")))

            ;;;; Rich Minority
      (use-package rich-minority
        :config
        (progn
          (setq rm-blacklist
                '(" =>"         ; aggressive-indent-mode
                  " AC"         ; auto-complete
                  " Anzu"       ; anzu mode
                  " abrv"       ; abbrev-mode
                  " Abbrev"     ; abbrev-mode
                  " ARev"       ; auto-revert
                  " be"         ; beginend
                  " (*)"        ; beacon
                  " company"    ; comppany-mode
                  " DC"         ; dup caps
                  " Dot"        ; dot mode
                  " GitGutter"  ; git-gutter-mode
                  " God"        ; god-mode
                  " Omit"       ; omit mode in dired
                  " VHl"        ; volatile highlights
                  " ctagsU"     ; ctags update
                  " wr"         ; Wrap Region
                  " SliNav"     ; elisp-slime-nav
                  " Rbow"       ; rainbow-mode
                  " PgLn"       ; page-line-break
                  " ElDoc"      ; eldoc
                  " GG"         ; ggtags
                  " hs"         ; hideshow
                  " hs+"        ;
                  " WK"         ; which-key
                  " Undo-Tree"  ; undo-tree
                  " h-i-g"      ; highlight-indent-guides
                  " *"          ; fancy narrow
                  " Projectile" ; projectile
                  " Wrap"       ; visual-line-mode
                  " yas"        ; yasnippet
                  " OrgSrc"     ; org source code
                  ))
          (setq rm-text-properties '(
                                     ("\\` Fill\\'"        'display " aF.")
                                     ("\\` Fly\\'"         'display (concat " " (propertize "🗹" 'face '((:foreground "darkgreen" :weight bold))))) ; flyspell
                                     ("\\` FlyC\\*\\'"     'display (concat " " (propertize "✔…" 'face '((:foreground "red" :weight bold))))) ; flycheck
                                     ("\\` FlyC\\!\\'"     'display (concat " " (propertize "✔!" 'face '((:foreground "red" :weight bold))))) ; flycheck
                                     ("\\` FlyC\\?\\'"     'display (concat " " (propertize "✔?" 'face '((:foreground "red" :weight bold))))) ; flycheck
                                     ("\\` FlyC\\-\\'"     'display (concat " " (propertize "✔-" 'face '((:foreground "red" :weight bold))))) ; flycheck
                                     ("\\` FlyC\\'"        'display (concat " " (propertize "✔" 'face '((:foreground "darkgreen" :weight bold))))) ; flycheck
                                     ("\\` FlyC.*\\'"      'display (concat " " (ale/flycheck-mode-line))) ; flycheck
                                     ("\\` Ovwrt\\'"       'display (concat " " (propertize "Ovwrt" 'face '((:foreground "white" :background "red"))))) ; Overwrite
                                     ("\\` SP/s\\'"        'display (concat " " (propertize "()" 'face '((:foreground "red")))))   ; smartparens-strict
                                     ("\\` SP\\'"          'display " ()")   ; smartparens
                                     ("\\` racer\\'"          'display " 🚄")   ; racer
                                     ("\\` cargo\\'"          'display " 🚢")   ; cargo
                                     ("\\` Server\\'"      'display " Σ")   ; Server
                                     ("\\` super-save\\'"  'display (concat " " (icons-in-terminal 'linea_basic_floppydisk)))   ; Server
                                     ("\\` Tail\\'"        'display " Tail.")
                                     ("\\` Temp\\'"        'display " t") ; temp-mode
                                     ("\\` Vis\\'"         'display " V")   ; visible-mode
                                     ("\\` rk\\'"          'display (concat " " (propertize "[]" 'face 'region))) ; Region bindings
                                     ("\\` mc:[0-9]+ *\\'" 'face 'font-lock-keyword-face) ; Multiple cursors
                                     ("\\` ([a-z]+)\\'"    'face '((:foreground "darkgreen" :weight bold))) ; guess-language-mode
                                     ))
          (sml/setup))))
  #+END_SRC

* Session saving & backups
  #+BEGIN_SRC emacs-lisp
    ;; auto-save file-visiting buffers
    (use-package super-save
      :disabled
      :config
      (super-save-mode +1)
      (setq super-save-auto-save-when-idle t
            auto-save-default nil))

    ;; Save a list of recent files visited.
    (use-package desktop
      :defer t
      :config
      (setq desktop-save t
            ;; desktop-base-lock-name      "lock"
            ;; desktop-dirname             user-emacs-directory
            ;; desktop-path                (list desktop-dirname)
            ;; desktop-files-not-to-save   "^$" ;reload tramp paths
            ;; desktop-load-locked-desktop t
            ;; (add-to-list 'desktop-modes-not-to-save 'dired-mode)
            )
      (desktop-save-mode 1)
      (add-hook 'desktop-after-read-hook (lambda () (set-cursor-color "yellow")))
      (desktop-read))
  #+END_SRC

* Server mode
  #+BEGIN_SRC emacs-lisp
    (use-package edit-server
      :if (and
           (window-system)
           (or
            (not (fboundp 'server-running-p))
            (not (server-running-p))))
      :bind ("M-#" . server-edit)) ;; send back to server, quicker than C-x #
  #+END_SRC

* Other
** Accounting
   I use [[http://out.easycounter.com/external/ledger-cli.org][ledger]] to manage my money. There is a corresponding major-mode:
   #+BEGIN_SRC emacs-lisp
     (use-package ledger-mode
       :mode ("\\.dat$")
       :config
       (setq ledger-clear-whole-transactions 1
             ledger-reports (("courant" "ledger ")
                             ("bal" "%(binary) -f %(ledger-file) bal")
                             ("reg" "%(binary) -f %(ledger-file) reg")
                             ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
                             ("account" "%(binary) -f %(ledger-file) reg %(account)"))))
   #+END_SRC

** Pomodoro
   #+BEGIN_SRC emacs-lisp
     (use-package tomatinho :disabled)
   #+END_SRC

** Demos
   #+BEGIN_SRC emacs-lisp
     (use-package command-log-mode :defer t)
   #+END_SRC

** Restclient
   #+BEGIN_SRC emacs-lisp
     ;; REST client
     (use-package restclient-helm
       :ensure restclient
       :mode ("restclient" . restclient-mode)
       :bind
       (:map restclient-mode-map
             ("C-c n w" . widen)))

     (use-package ob-restclient)
   #+END_SRC

** Web pasting
   #+BEGIN_SRC emacs-lisp
     (use-package webpaste
       :defer t
       :config
       ;; Open recently created pastes in an external browser
       (setq webpaste-open-in-browser t))
   #+END_SRC

** Spritz
   [[http://spritzinc.com/][spritz]] is a reading technique. [[https://github.com/emacsmirror/spray][Spray-mode]] implements it for any emacs buffer.
   #+BEGIN_SRC emacs-lisp
     ;; spray mode (spritz)
     (use-package spray
       :disabled
       :bind (:map spray-mode-map
                   ("-" . spray-slower)
                   ("+" . spray-faster)
                   ("<SPC>" . spray-start/stop)
                   ("b" . spray-backward-word)
                   ("p" . spray-backward-word)
                   ("f" . spray-forward-word)
                   ("n" . spray-forward-word)))
   #+END_SRC

** epub
   It now seems possible to read epub documents (ebooks) from within emacs:
   #+BEGIN_SRC emacs-lisp
     (use-package nov)
   #+END_SRC

** Text filling
   Lorem ipsum text filler:
   #+BEGIN_SRC emacs-lisp
     (use-package lorem-ipsum :defer t)
   #+END_SRC

** Music
   #+BEGIN_SRC emacs-lisp
     (use-package helm-spotify-plus :disabled)
   #+END_SRC

** Youtube
   #+BEGIN_SRC emacs-lisp
     (defun play-youtube-video (url)
       (interactive "sURL: ")
       (shell-command
        (concat "youtube-dl  -o - " url " | vlc -")))

     (defun w3m-play-youtube-video ()
       (interactive)
       (play-youtube-video
        (w3m-print-this-url (point))))
   #+END_SRC

** Games
*** Typing
    #+BEGIN_SRC emacs-lisp
      (use-package speed-type :defer t)
    #+END_SRC

*** Other
    #+BEGIN_SRC emacs-lisp
      (use-package 2048-game :defer t)
      (use-package vimgolf
        :ensure nil
        :commands vimgolf
        :load-path "elisp/")
      (use-package slime-volleyball :defer t)
    #+END_SRC
** News
*** RSS feeds
**** Avandu
     Avandu is a gateway to Tiny Tiny RSS.
     #+BEGIN_SRC emacs-lisp
       (use-package avandu
         :bind (:map avandu-article-mode-map
                     ("p" . previous-line)
                     ("n" . next-line)
                     ("l" . recenter-top-bottom)
                     :map avandu-overview-map
                     ("<tab>" . avandu-next-feed)
                     ("<backtab>" . avandu-previous-feed)
                     ("l" . recenter-top-bottom)
                     ("v" . scroll-up-command))
         :config (setq avandu-tt-rss-api-url my-private-personal-tt-rss-api-url
                       avandu-user my-private-personal-tt-rss-username
                       avandu-password my-private-personal-tt-rss-password))
     #+END_SRC

**** Elfeed
     #+BEGIN_SRC emacs-lisp
       (use-package elfeed :defer t
         :config (setq elfeed-feeds my-private-feeds))

       (use-package elfeed-org
         :defer t
         :after elfeed
         :config
         (elfeed-org)
         (setq rmh-elfeed-org-auto-ignore-invalid-feeds t
               rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org")))
     #+END_SRC

*** Stories
    #+BEGIN_SRC emacs-lisp
      (use-package helm-lobsters
      :commands helm-lobsters)
    #+END_SRC

* Useful links
** blogs
   - http://sachachua.com/blog/
** vlogs
   - http://emacsrocks.com/
   - https://mickael.kerjean.me/2017/03/18/emacs-tutorial-series-episode-0/
   - https://cestlaz.github.io/stories/emacs/
** configs
   - https://github.com/purcell/emacs.d
   - https://github.com/dakra/dmacs/blob/master/init.org
   - https://github.com/angrybacon/dotemacs
   - https://github.com/jwiegley/dot-emacs
** other
   - https://github.com/sebastiencs
